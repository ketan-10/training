{{- $tableNameCamel := camelCase .Table.TableName -}}
package table

import (
    sq "github.com/elgris/sqrl"
    "github.com/pkg/errors"
)

type {{ $tableNameCamel }} struct {
{{- range .Table.Columns}}
{{- if and .IsEnum (eq .NotNullable false) }}
    {{ camelCase .ColumnName }} *{{ .GoType }} `json:"{{.ColumnName}}" db:"{{.ColumnName}}"`
{{ else }}
    {{ camelCase .ColumnName }} {{ .GoType }} `json:"{{.ColumnName}}" db:"{{.ColumnName}}"`
{{- end }}
{{- end }}
}

type {{ $tableNameCamel }}Filter struct {
{{- range .Table.Columns}}
    {{ camelCase .ColumnName }} internal.FilterOnField 
{{- end }}
    Wheres []sq.Sqlizer
    Joins []sq.Sqlizer
    LeftJoins []sq.Sqlizer
    GroupBys []string
    Havings []sq.Sqlizer
}

func (f *{{ $tableNameCamel }}Filter) NewFilter() interface{} {
    if f == nil {
        return &{{ $tableNameCamel }}Filter{}
    }
    return f
}

func (f *{{ $tableNameCamel }}Filter) TableName() string {
    return "`{{ .Table.TableName }}`"
}

func (f *{{ $tableNameCamel }}Filter) ModuleName() string {
    return "{{ .Table.TableName }}"
}

func (f *{{ $tableNameCamel }}Filter) IsNil() bool {
    return f == nil
}

{{- range .Table.Columns}}
func (f *{{ $tableNameCamel }}Filter) Add{{ camelCase .ColumnName }}(filterType internal.FilterType, v interface{}) {
    f.{{camelCase .ColumnName }} = append(f.{{camelCase .ColumnName }}, map[internal.FilterType]interface{}{filterType: v})
}
{{- end }}

func (f *{{ $tableNameCamel }}Filter) Where(v sq.Sqlizer) *{{ $tableNameCamel }}Filter {
    f.Wheres = append(f.Wheres, v)
    return f
}


func (f *{{ $tableNameCamel }}Filter) Join(j sq.Sqlizer) *{{ $tableNameCamel }}Filter {
    f.Joins = append(f.Joins, j)
    return f
}

func (f *{{ $tableNameCamel }}Filter) LeftJoin(j sq.Sqlizer) *{{ $tableNameCamel }}Filter {
    f.LeftJoins = append(f.LeftJoins, j)
    return f
}

func (f *{{ $tableNameCamel }}Filter) GroupBy(gb string) *{{ $tableNameCamel }}Filter {
    f.GroupBys = append(f.GroupBys, gb)
    return f
}

func (f *{{ $tableNameCamel }}Filter) Having(h sq.Sqlizer) *{{ $tableNameCamel }}Filter {
    f.Havings = append(f.Havings, h)
    return f
}

type {{ $tableNameCamel }}Create struct {
{{- range .Table.Columns}}
    {{- if and (ne .ColumnName "id") (ne .ColumnName "created_at") (ne .ColumnName "updated_at") (ne .ColumnName "active")}}
    {{ camelCase .ColumnName }} {{- if and .IsEnum (eq .NotNullable false) }} *{{ .GoType }}{{ else }} {{ .GoType }}{{- end}} `json:"{{.ColumnName}}" db:"{{.ColumnName}}"`
    {{- end}}
{{- end }}
}

// TODO: We have to exclude AutoGenerated fields
// For now I am keeping it in, as not sure how it affects
type {{ $tableNameCamel }}Update struct {
{{- range .Table.Columns}}
    {{- if and (ne .ColumnName "id") (ne .ColumnName "created_at") (ne .ColumnName "updated_at") }}
    {{ camelCase .ColumnName }} *{{ .GoType }} // {{.ColumnName}}
    {{- end}}
{{- end }}
}


// helper functions
func (u *{{ $tableNameCamel }}Update) To{{ $tableNameCamel }}Create() (res {{ $tableNameCamel }}Create, err error) {
{{- range .Table.Columns}}
{{- if eq .IsGenerated false }}
    if u.{{ camelCase .ColumnName }} != nil {
        res.{{ camelCase .ColumnName }} = *u.{{ camelCase .ColumnName }}
    }
    {{- if eq .NotNullable true -}} 
    {{" "}}else {
        return res, errors.New("Value Can not be NULL")
    } 
    {{- end -}}
{{- end -}}
{{- end }}
    return res, nil
}

type List{{ $tableNameCamel }} struct {
    TotalCount int
    Data []{{ $tableNameCamel }}
}

{{- range .Table.Columns }}
    {{- if and .IsEnum (eq .NotNullable false) }}
func (l *List{{ $tableNameCamel }}) GetAll{{ camelCase .ColumnName }}() []*{{ .GoType }} {
    var res []*{{ .GoType }}
    for _, item := range l.Data {
        res = append(res, item.{{ camelCase .ColumnName }})
    }
    return res
}
    {{- else }}
func (l *List{{ $tableNameCamel }}) GetAll{{ camelCase .ColumnName }}() []{{ .GoType }} {
    var res []{{ .GoType }}
    for _, item := range l.Data {
        res = append(res, item.{{ camelCase .ColumnName }})
    }
    return res
}
    {{- end }}
{{- end }}

func (l *List{{ $tableNameCamel }}) Filter(f func (item {{ $tableNameCamel }}) bool) (res List{{ $tableNameCamel }}) {
    for _, item := range l.Data {
        if f(item) {
            res.Data = append(res.Data, item)
        }
    }
    res.TotalCount = len(res.Data)
    return res
}

func (l *List{{ $tableNameCamel }}) Find(f func (item {{ $tableNameCamel }}) bool) (res {{ $tableNameCamel }}, found bool) {
    for _, item := range l.Data {
        if f(item) {
            return item, true
        }
    }
    return {{ $tableNameCamel }}{}, false
}



{{- range .Indexes}}
    
{{- if or (ne (index .Columns 0).Column.IsEnum true) (index .Columns 0).Column.NotNullable }}
    {{- if and (.IsUnique) (eq ( len .Columns ) 1) }}
func (l *List{{ $tableNameCamel }}) MapBy{{ camelCase (index .Columns 0).ColumnName }}() (m map[{{ (index .Columns 0).Column.GoType }}]{{ $tableNameCamel }}) {
    m = make (map[{{ (index .Columns 0).Column.GoType }}]{{ $tableNameCamel }}, len(l.Data))
    for _, item := range l.Data {
        m[item.{{ camelCase (index .Columns 0).ColumnName }}] = item
    }
    return m
}

    {{else}}

func (l *List{{ $tableNameCamel }}) MapBy{{ camelCase (index .Columns 0).ColumnName }}() (m map[{{ (index .Columns 0).Column.GoType }}]List{{ $tableNameCamel }}) {
    m = make (map[{{ (index .Columns 0).Column.GoType }}]List{{ $tableNameCamel }})
    for _, item := range l.Data {
        list := m[item.{{ camelCase (index .Columns 0).ColumnName }}]
        list.Data = append(list.Data, item)

        m[item.{{ camelCase (index .Columns 0).ColumnName }}] = list
    }
    for k, v := range m {
        v.TotalCount = len(v.Data)
        m[k] = v
    }
    return m
}

    {{end}}
{{end}}
{{end}}

