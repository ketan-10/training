// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gen

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/ketan-10/training/backend/internal"
	"github.com/ketan-10/training/backend/xo_gen/enum"
	"github.com/ketan-10/training/backend/xo_gen/table"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Attendances() AttendancesResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Registrations() RegistrationsResolver
	Students() StudentsResolver
	TrainerTrainingMapping() TrainerTrainingMappingResolver
	Trainers() TrainersResolver
	Training() TrainingResolver
	TrainingEvent() TrainingEventResolver
	User() UserResolver
}

type DirectiveRoot struct {
	Authenticate func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Attendances struct {
		Active                         func(childComplexity int) int
		CreatedAt                      func(childComplexity int) int
		FkStudent                      func(childComplexity int) int
		FkTrainingEvent                func(childComplexity int) int
		ID                             func(childComplexity int) int
		StudentsByFkStudent            func(childComplexity int, filter *table.StudentsFilter) int
		TrainingEventByFkTrainingEvent func(childComplexity int, filter *table.TrainingEventFilter) int
		UpdatedAt                      func(childComplexity int) int
	}

	ListAttendances struct {
		Data       func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ListRegistrations struct {
		Data       func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ListStudents struct {
		Data       func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ListTrainerTrainingMapping struct {
		Data       func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ListTrainers struct {
		Data       func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ListTraining struct {
		Data       func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ListTrainingEvent struct {
		Data       func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ListUser struct {
		Data       func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	Mutation struct {
		DeleteRegistrationsByID              func(childComplexity int, id int) int
		DeleteStudentsByID                   func(childComplexity int, id int) int
		DeleteTrainerTrainingMappingByID     func(childComplexity int, id int) int
		DeleteTrainersByID                   func(childComplexity int, id int) int
		DeleteTrainingByID                   func(childComplexity int, id int) int
		DeleteTrainingEventByID              func(childComplexity int, id int) int
		DeleteUserByID                       func(childComplexity int, id int) int
		InsertRegistrations                  func(childComplexity int, data table.RegistrationsCreate) int
		InsertStudents                       func(childComplexity int, data table.StudentsCreate) int
		InsertTrainerTrainingMapping         func(childComplexity int, data table.TrainerTrainingMappingCreate) int
		InsertTrainers                       func(childComplexity int, data table.TrainersCreate) int
		InsertTraining                       func(childComplexity int, data table.TrainingCreate) int
		InsertTrainingEvent                  func(childComplexity int, data table.TrainingEventCreate) int
		InsertUser                           func(childComplexity int, data table.UserCreate) int
		UpdateRegistrationsByFields          func(childComplexity int, id int, data table.RegistrationsUpdate) int
		UpdateStudentsByFields               func(childComplexity int, id int, data table.StudentsUpdate) int
		UpdateTrainerTrainingMappingByFields func(childComplexity int, id int, data table.TrainerTrainingMappingUpdate) int
		UpdateTrainersByFields               func(childComplexity int, id int, data table.TrainersUpdate) int
		UpdateTrainingByFields               func(childComplexity int, id int, data table.TrainingUpdate) int
		UpdateTrainingEventByFields          func(childComplexity int, id int, data table.TrainingEventUpdate) int
		UpdateUserByFields                   func(childComplexity int, id int, data table.UserUpdate) int
	}

	Query struct {
		FindAllRegistrations          func(childComplexity int, filter *table.RegistrationsFilter, pagination *internal.Pagination) int
		FindAllStudents               func(childComplexity int, filter *table.StudentsFilter, pagination *internal.Pagination) int
		FindAllTrainerTrainingMapping func(childComplexity int, filter *table.TrainerTrainingMappingFilter, pagination *internal.Pagination) int
		FindAllTrainers               func(childComplexity int, filter *table.TrainersFilter, pagination *internal.Pagination) int
		FindAllTraining               func(childComplexity int, filter *table.TrainingFilter, pagination *internal.Pagination) int
		FindAllTrainingEvent          func(childComplexity int, filter *table.TrainingEventFilter, pagination *internal.Pagination) int
		FindAllUser                   func(childComplexity int, filter *table.UserFilter, pagination *internal.Pagination) int
		Login                         func(childComplexity int, email string, password string) int
	}

	Registrations struct {
		Active               func(childComplexity int) int
		CreatedAt            func(childComplexity int) int
		FkStudent            func(childComplexity int) int
		FkTraining           func(childComplexity int) int
		ID                   func(childComplexity int) int
		StudentsByFkStudent  func(childComplexity int, filter *table.StudentsFilter) int
		TrainingByFkTraining func(childComplexity int, filter *table.TrainingFilter) int
		UpdatedAt            func(childComplexity int) int
	}

	Students struct {
		Active                            func(childComplexity int) int
		AttendancesByFkStudent            func(childComplexity int, filter *table.AttendancesFilter, pagination *internal.Pagination) int
		ClassName                         func(childComplexity int) int
		CreatedAt                         func(childComplexity int) int
		CreatedBy                         func(childComplexity int) int
		Designation                       func(childComplexity int) int
		Email                             func(childComplexity int) int
		ID                                func(childComplexity int) int
		MobilePhone                       func(childComplexity int) int
		Name                              func(childComplexity int) int
		RegistrationsByFkStudent          func(childComplexity int, filter *table.RegistrationsFilter, pagination *internal.Pagination) int
		TrainerTrainingMappingByFkStudent func(childComplexity int, filter *table.TrainerTrainingMappingFilter, pagination *internal.Pagination) int
		UUID                              func(childComplexity int) int
		UpdatedAt                         func(childComplexity int) int
		UserByCreatedBy                   func(childComplexity int, filter *table.UserFilter) int
	}

	TrainerTrainingMapping struct {
		Active                         func(childComplexity int) int
		CreatedAt                      func(childComplexity int) int
		FkStudent                      func(childComplexity int) int
		FkTrainer                      func(childComplexity int) int
		FkTrainingEvent                func(childComplexity int) int
		ID                             func(childComplexity int) int
		StudentsByFkStudent            func(childComplexity int, filter *table.StudentsFilter) int
		TrainersByFkTrainer            func(childComplexity int, filter *table.TrainersFilter) int
		TrainingEventByFkTrainingEvent func(childComplexity int, filter *table.TrainingEventFilter) int
		UpdatedAt                      func(childComplexity int) int
	}

	Trainers struct {
		Active                            func(childComplexity int) int
		CreatedAt                         func(childComplexity int) int
		CreatedBy                         func(childComplexity int) int
		Designation                       func(childComplexity int) int
		Email                             func(childComplexity int) int
		ID                                func(childComplexity int) int
		MobilePhone                       func(childComplexity int) int
		Name                              func(childComplexity int) int
		TrainerTrainingMappingByFkTrainer func(childComplexity int, filter *table.TrainerTrainingMappingFilter, pagination *internal.Pagination) int
		UUID                              func(childComplexity int) int
		UpdatedAt                         func(childComplexity int) int
		UserByCreatedBy                   func(childComplexity int, filter *table.UserFilter) int
	}

	Training struct {
		Active                    func(childComplexity int) int
		CreatedAt                 func(childComplexity int) int
		CreatedBy                 func(childComplexity int) int
		ID                        func(childComplexity int) int
		IsRegistrationRequired    func(childComplexity int) int
		Mode                      func(childComplexity int) int
		RegistrationsByFkTraining func(childComplexity int, filter *table.RegistrationsFilter, pagination *internal.Pagination) int
		RequestedBy               func(childComplexity int) int
		Tags                      func(childComplexity int) int
		TrainingEventByFkTraining func(childComplexity int, filter *table.TrainingEventFilter, pagination *internal.Pagination) int
		TrainingName              func(childComplexity int) int
		Type                      func(childComplexity int) int
		UpdatedAt                 func(childComplexity int) int
		UserByCreatedBy           func(childComplexity int, filter *table.UserFilter) int
		UserByRequestedBy         func(childComplexity int, filter *table.UserFilter) int
	}

	TrainingEvent struct {
		Active                                  func(childComplexity int) int
		AttendancesByFkTrainingEvent            func(childComplexity int, filter *table.AttendancesFilter, pagination *internal.Pagination) int
		CompletedOn                             func(childComplexity int) int
		CreatedAt                               func(childComplexity int) int
		CreatedBy                               func(childComplexity int) int
		Duration                                func(childComplexity int) int
		FkTraining                              func(childComplexity int) int
		From                                    func(childComplexity int) int
		ID                                      func(childComplexity int) int
		Status                                  func(childComplexity int) int
		TrainerTrainingMappingByFkTrainingEvent func(childComplexity int, filter *table.TrainerTrainingMappingFilter, pagination *internal.Pagination) int
		TrainingByFkTraining                    func(childComplexity int, filter *table.TrainingFilter) int
		UpdatedAt                               func(childComplexity int) int
		UserByCreatedBy                         func(childComplexity int, filter *table.UserFilter) int
	}

	User struct {
		Active                   func(childComplexity int) int
		CreatedAt                func(childComplexity int) int
		Email                    func(childComplexity int) int
		ID                       func(childComplexity int) int
		Name                     func(childComplexity int) int
		Password                 func(childComplexity int) int
		Role                     func(childComplexity int) int
		StudentsByCreatedBy      func(childComplexity int, filter *table.StudentsFilter, pagination *internal.Pagination) int
		TrainersByCreatedBy      func(childComplexity int, filter *table.TrainersFilter, pagination *internal.Pagination) int
		TrainingByCreatedBy      func(childComplexity int, filter *table.TrainingFilter, pagination *internal.Pagination) int
		TrainingByRequestedBy    func(childComplexity int, filter *table.TrainingFilter, pagination *internal.Pagination) int
		TrainingEventByCreatedBy func(childComplexity int, filter *table.TrainingEventFilter, pagination *internal.Pagination) int
		UpdatedAt                func(childComplexity int) int
	}
}

type AttendancesResolver interface {
	TrainingEventByFkTrainingEvent(ctx context.Context, obj *table.Attendances, filter *table.TrainingEventFilter) (*table.TrainingEvent, error)
	StudentsByFkStudent(ctx context.Context, obj *table.Attendances, filter *table.StudentsFilter) (*table.Students, error)
}
type MutationResolver interface {
	InsertUser(ctx context.Context, data table.UserCreate) (*table.User, error)
	UpdateUserByFields(ctx context.Context, id int, data table.UserUpdate) (*table.User, error)
	DeleteUserByID(ctx context.Context, id int) (bool, error)
	InsertTrainers(ctx context.Context, data table.TrainersCreate) (*table.Trainers, error)
	UpdateTrainersByFields(ctx context.Context, id int, data table.TrainersUpdate) (*table.Trainers, error)
	DeleteTrainersByID(ctx context.Context, id int) (bool, error)
	InsertStudents(ctx context.Context, data table.StudentsCreate) (*table.Students, error)
	UpdateStudentsByFields(ctx context.Context, id int, data table.StudentsUpdate) (*table.Students, error)
	DeleteStudentsByID(ctx context.Context, id int) (bool, error)
	InsertRegistrations(ctx context.Context, data table.RegistrationsCreate) (*table.Registrations, error)
	UpdateRegistrationsByFields(ctx context.Context, id int, data table.RegistrationsUpdate) (*table.Registrations, error)
	DeleteRegistrationsByID(ctx context.Context, id int) (bool, error)
	InsertTrainerTrainingMapping(ctx context.Context, data table.TrainerTrainingMappingCreate) (*table.TrainerTrainingMapping, error)
	UpdateTrainerTrainingMappingByFields(ctx context.Context, id int, data table.TrainerTrainingMappingUpdate) (*table.TrainerTrainingMapping, error)
	DeleteTrainerTrainingMappingByID(ctx context.Context, id int) (bool, error)
	InsertTrainingEvent(ctx context.Context, data table.TrainingEventCreate) (*table.TrainingEvent, error)
	UpdateTrainingEventByFields(ctx context.Context, id int, data table.TrainingEventUpdate) (*table.TrainingEvent, error)
	DeleteTrainingEventByID(ctx context.Context, id int) (bool, error)
	InsertTraining(ctx context.Context, data table.TrainingCreate) (*table.Training, error)
	UpdateTrainingByFields(ctx context.Context, id int, data table.TrainingUpdate) (*table.Training, error)
	DeleteTrainingByID(ctx context.Context, id int) (bool, error)
}
type QueryResolver interface {
	Login(ctx context.Context, email string, password string) (string, error)
	FindAllUser(ctx context.Context, filter *table.UserFilter, pagination *internal.Pagination) (*table.ListUser, error)
	FindAllTrainers(ctx context.Context, filter *table.TrainersFilter, pagination *internal.Pagination) (*table.ListTrainers, error)
	FindAllStudents(ctx context.Context, filter *table.StudentsFilter, pagination *internal.Pagination) (*table.ListStudents, error)
	FindAllRegistrations(ctx context.Context, filter *table.RegistrationsFilter, pagination *internal.Pagination) (*table.ListRegistrations, error)
	FindAllTrainerTrainingMapping(ctx context.Context, filter *table.TrainerTrainingMappingFilter, pagination *internal.Pagination) (*table.ListTrainerTrainingMapping, error)
	FindAllTrainingEvent(ctx context.Context, filter *table.TrainingEventFilter, pagination *internal.Pagination) (*table.ListTrainingEvent, error)
	FindAllTraining(ctx context.Context, filter *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error)
}
type RegistrationsResolver interface {
	TrainingByFkTraining(ctx context.Context, obj *table.Registrations, filter *table.TrainingFilter) (*table.Training, error)
	StudentsByFkStudent(ctx context.Context, obj *table.Registrations, filter *table.StudentsFilter) (*table.Students, error)
}
type StudentsResolver interface {
	UserByCreatedBy(ctx context.Context, obj *table.Students, filter *table.UserFilter) (*table.User, error)
	AttendancesByFkStudent(ctx context.Context, obj *table.Students, filter *table.AttendancesFilter, pagination *internal.Pagination) (*table.ListAttendances, error)
	RegistrationsByFkStudent(ctx context.Context, obj *table.Students, filter *table.RegistrationsFilter, pagination *internal.Pagination) (*table.ListRegistrations, error)
	TrainerTrainingMappingByFkStudent(ctx context.Context, obj *table.Students, filter *table.TrainerTrainingMappingFilter, pagination *internal.Pagination) (*table.ListTrainerTrainingMapping, error)
}
type TrainerTrainingMappingResolver interface {
	TrainingEventByFkTrainingEvent(ctx context.Context, obj *table.TrainerTrainingMapping, filter *table.TrainingEventFilter) (*table.TrainingEvent, error)
	TrainersByFkTrainer(ctx context.Context, obj *table.TrainerTrainingMapping, filter *table.TrainersFilter) (*table.Trainers, error)
	StudentsByFkStudent(ctx context.Context, obj *table.TrainerTrainingMapping, filter *table.StudentsFilter) (*table.Students, error)
}
type TrainersResolver interface {
	UserByCreatedBy(ctx context.Context, obj *table.Trainers, filter *table.UserFilter) (*table.User, error)
	TrainerTrainingMappingByFkTrainer(ctx context.Context, obj *table.Trainers, filter *table.TrainerTrainingMappingFilter, pagination *internal.Pagination) (*table.ListTrainerTrainingMapping, error)
}
type TrainingResolver interface {
	UserByRequestedBy(ctx context.Context, obj *table.Training, filter *table.UserFilter) (*table.User, error)
	UserByCreatedBy(ctx context.Context, obj *table.Training, filter *table.UserFilter) (*table.User, error)
	RegistrationsByFkTraining(ctx context.Context, obj *table.Training, filter *table.RegistrationsFilter, pagination *internal.Pagination) (*table.ListRegistrations, error)
	TrainingEventByFkTraining(ctx context.Context, obj *table.Training, filter *table.TrainingEventFilter, pagination *internal.Pagination) (*table.ListTrainingEvent, error)
}
type TrainingEventResolver interface {
	TrainingByFkTraining(ctx context.Context, obj *table.TrainingEvent, filter *table.TrainingFilter) (*table.Training, error)
	UserByCreatedBy(ctx context.Context, obj *table.TrainingEvent, filter *table.UserFilter) (*table.User, error)
	AttendancesByFkTrainingEvent(ctx context.Context, obj *table.TrainingEvent, filter *table.AttendancesFilter, pagination *internal.Pagination) (*table.ListAttendances, error)
	TrainerTrainingMappingByFkTrainingEvent(ctx context.Context, obj *table.TrainingEvent, filter *table.TrainerTrainingMappingFilter, pagination *internal.Pagination) (*table.ListTrainerTrainingMapping, error)
}
type UserResolver interface {
	StudentsByCreatedBy(ctx context.Context, obj *table.User, filter *table.StudentsFilter, pagination *internal.Pagination) (*table.ListStudents, error)
	TrainersByCreatedBy(ctx context.Context, obj *table.User, filter *table.TrainersFilter, pagination *internal.Pagination) (*table.ListTrainers, error)
	TrainingByRequestedBy(ctx context.Context, obj *table.User, filter *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error)
	TrainingByCreatedBy(ctx context.Context, obj *table.User, filter *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error)
	TrainingEventByCreatedBy(ctx context.Context, obj *table.User, filter *table.TrainingEventFilter, pagination *internal.Pagination) (*table.ListTrainingEvent, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Attendances.active":
		if e.complexity.Attendances.Active == nil {
			break
		}

		return e.complexity.Attendances.Active(childComplexity), true

	case "Attendances.createdAt":
		if e.complexity.Attendances.CreatedAt == nil {
			break
		}

		return e.complexity.Attendances.CreatedAt(childComplexity), true

	case "Attendances.fkStudent":
		if e.complexity.Attendances.FkStudent == nil {
			break
		}

		return e.complexity.Attendances.FkStudent(childComplexity), true

	case "Attendances.fkTrainingEvent":
		if e.complexity.Attendances.FkTrainingEvent == nil {
			break
		}

		return e.complexity.Attendances.FkTrainingEvent(childComplexity), true

	case "Attendances.id":
		if e.complexity.Attendances.ID == nil {
			break
		}

		return e.complexity.Attendances.ID(childComplexity), true

	case "Attendances.studentsByFkStudent":
		if e.complexity.Attendances.StudentsByFkStudent == nil {
			break
		}

		args, err := ec.field_Attendances_studentsByFkStudent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Attendances.StudentsByFkStudent(childComplexity, args["filter"].(*table.StudentsFilter)), true

	case "Attendances.trainingEventByFkTrainingEvent":
		if e.complexity.Attendances.TrainingEventByFkTrainingEvent == nil {
			break
		}

		args, err := ec.field_Attendances_trainingEventByFkTrainingEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Attendances.TrainingEventByFkTrainingEvent(childComplexity, args["filter"].(*table.TrainingEventFilter)), true

	case "Attendances.updatedAt":
		if e.complexity.Attendances.UpdatedAt == nil {
			break
		}

		return e.complexity.Attendances.UpdatedAt(childComplexity), true

	case "ListAttendances.data":
		if e.complexity.ListAttendances.Data == nil {
			break
		}

		return e.complexity.ListAttendances.Data(childComplexity), true

	case "ListAttendances.totalCount":
		if e.complexity.ListAttendances.TotalCount == nil {
			break
		}

		return e.complexity.ListAttendances.TotalCount(childComplexity), true

	case "ListRegistrations.data":
		if e.complexity.ListRegistrations.Data == nil {
			break
		}

		return e.complexity.ListRegistrations.Data(childComplexity), true

	case "ListRegistrations.totalCount":
		if e.complexity.ListRegistrations.TotalCount == nil {
			break
		}

		return e.complexity.ListRegistrations.TotalCount(childComplexity), true

	case "ListStudents.data":
		if e.complexity.ListStudents.Data == nil {
			break
		}

		return e.complexity.ListStudents.Data(childComplexity), true

	case "ListStudents.totalCount":
		if e.complexity.ListStudents.TotalCount == nil {
			break
		}

		return e.complexity.ListStudents.TotalCount(childComplexity), true

	case "ListTrainerTrainingMapping.data":
		if e.complexity.ListTrainerTrainingMapping.Data == nil {
			break
		}

		return e.complexity.ListTrainerTrainingMapping.Data(childComplexity), true

	case "ListTrainerTrainingMapping.totalCount":
		if e.complexity.ListTrainerTrainingMapping.TotalCount == nil {
			break
		}

		return e.complexity.ListTrainerTrainingMapping.TotalCount(childComplexity), true

	case "ListTrainers.data":
		if e.complexity.ListTrainers.Data == nil {
			break
		}

		return e.complexity.ListTrainers.Data(childComplexity), true

	case "ListTrainers.totalCount":
		if e.complexity.ListTrainers.TotalCount == nil {
			break
		}

		return e.complexity.ListTrainers.TotalCount(childComplexity), true

	case "ListTraining.data":
		if e.complexity.ListTraining.Data == nil {
			break
		}

		return e.complexity.ListTraining.Data(childComplexity), true

	case "ListTraining.totalCount":
		if e.complexity.ListTraining.TotalCount == nil {
			break
		}

		return e.complexity.ListTraining.TotalCount(childComplexity), true

	case "ListTrainingEvent.data":
		if e.complexity.ListTrainingEvent.Data == nil {
			break
		}

		return e.complexity.ListTrainingEvent.Data(childComplexity), true

	case "ListTrainingEvent.totalCount":
		if e.complexity.ListTrainingEvent.TotalCount == nil {
			break
		}

		return e.complexity.ListTrainingEvent.TotalCount(childComplexity), true

	case "ListUser.data":
		if e.complexity.ListUser.Data == nil {
			break
		}

		return e.complexity.ListUser.Data(childComplexity), true

	case "ListUser.totalCount":
		if e.complexity.ListUser.TotalCount == nil {
			break
		}

		return e.complexity.ListUser.TotalCount(childComplexity), true

	case "Mutation.deleteRegistrationsByID":
		if e.complexity.Mutation.DeleteRegistrationsByID == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRegistrationsByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRegistrationsByID(childComplexity, args["id"].(int)), true

	case "Mutation.deleteStudentsByID":
		if e.complexity.Mutation.DeleteStudentsByID == nil {
			break
		}

		args, err := ec.field_Mutation_deleteStudentsByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteStudentsByID(childComplexity, args["id"].(int)), true

	case "Mutation.deleteTrainerTrainingMappingByID":
		if e.complexity.Mutation.DeleteTrainerTrainingMappingByID == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTrainerTrainingMappingByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTrainerTrainingMappingByID(childComplexity, args["id"].(int)), true

	case "Mutation.deleteTrainersByID":
		if e.complexity.Mutation.DeleteTrainersByID == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTrainersByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTrainersByID(childComplexity, args["id"].(int)), true

	case "Mutation.deleteTrainingByID":
		if e.complexity.Mutation.DeleteTrainingByID == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTrainingByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTrainingByID(childComplexity, args["id"].(int)), true

	case "Mutation.deleteTrainingEventByID":
		if e.complexity.Mutation.DeleteTrainingEventByID == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTrainingEventByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTrainingEventByID(childComplexity, args["id"].(int)), true

	case "Mutation.deleteUserByID":
		if e.complexity.Mutation.DeleteUserByID == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUserByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUserByID(childComplexity, args["id"].(int)), true

	case "Mutation.insertRegistrations":
		if e.complexity.Mutation.InsertRegistrations == nil {
			break
		}

		args, err := ec.field_Mutation_insertRegistrations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InsertRegistrations(childComplexity, args["data"].(table.RegistrationsCreate)), true

	case "Mutation.insertStudents":
		if e.complexity.Mutation.InsertStudents == nil {
			break
		}

		args, err := ec.field_Mutation_insertStudents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InsertStudents(childComplexity, args["data"].(table.StudentsCreate)), true

	case "Mutation.insertTrainerTrainingMapping":
		if e.complexity.Mutation.InsertTrainerTrainingMapping == nil {
			break
		}

		args, err := ec.field_Mutation_insertTrainerTrainingMapping_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InsertTrainerTrainingMapping(childComplexity, args["data"].(table.TrainerTrainingMappingCreate)), true

	case "Mutation.insertTrainers":
		if e.complexity.Mutation.InsertTrainers == nil {
			break
		}

		args, err := ec.field_Mutation_insertTrainers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InsertTrainers(childComplexity, args["data"].(table.TrainersCreate)), true

	case "Mutation.insertTraining":
		if e.complexity.Mutation.InsertTraining == nil {
			break
		}

		args, err := ec.field_Mutation_insertTraining_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InsertTraining(childComplexity, args["data"].(table.TrainingCreate)), true

	case "Mutation.insertTrainingEvent":
		if e.complexity.Mutation.InsertTrainingEvent == nil {
			break
		}

		args, err := ec.field_Mutation_insertTrainingEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InsertTrainingEvent(childComplexity, args["data"].(table.TrainingEventCreate)), true

	case "Mutation.insertUser":
		if e.complexity.Mutation.InsertUser == nil {
			break
		}

		args, err := ec.field_Mutation_insertUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InsertUser(childComplexity, args["data"].(table.UserCreate)), true

	case "Mutation.updateRegistrationsByFields":
		if e.complexity.Mutation.UpdateRegistrationsByFields == nil {
			break
		}

		args, err := ec.field_Mutation_updateRegistrationsByFields_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRegistrationsByFields(childComplexity, args["id"].(int), args["data"].(table.RegistrationsUpdate)), true

	case "Mutation.updateStudentsByFields":
		if e.complexity.Mutation.UpdateStudentsByFields == nil {
			break
		}

		args, err := ec.field_Mutation_updateStudentsByFields_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateStudentsByFields(childComplexity, args["id"].(int), args["data"].(table.StudentsUpdate)), true

	case "Mutation.updateTrainerTrainingMappingByFields":
		if e.complexity.Mutation.UpdateTrainerTrainingMappingByFields == nil {
			break
		}

		args, err := ec.field_Mutation_updateTrainerTrainingMappingByFields_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTrainerTrainingMappingByFields(childComplexity, args["id"].(int), args["data"].(table.TrainerTrainingMappingUpdate)), true

	case "Mutation.updateTrainersByFields":
		if e.complexity.Mutation.UpdateTrainersByFields == nil {
			break
		}

		args, err := ec.field_Mutation_updateTrainersByFields_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTrainersByFields(childComplexity, args["id"].(int), args["data"].(table.TrainersUpdate)), true

	case "Mutation.updateTrainingByFields":
		if e.complexity.Mutation.UpdateTrainingByFields == nil {
			break
		}

		args, err := ec.field_Mutation_updateTrainingByFields_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTrainingByFields(childComplexity, args["id"].(int), args["data"].(table.TrainingUpdate)), true

	case "Mutation.updateTrainingEventByFields":
		if e.complexity.Mutation.UpdateTrainingEventByFields == nil {
			break
		}

		args, err := ec.field_Mutation_updateTrainingEventByFields_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTrainingEventByFields(childComplexity, args["id"].(int), args["data"].(table.TrainingEventUpdate)), true

	case "Mutation.updateUserByFields":
		if e.complexity.Mutation.UpdateUserByFields == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserByFields_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserByFields(childComplexity, args["id"].(int), args["data"].(table.UserUpdate)), true

	case "Query.findAllRegistrations":
		if e.complexity.Query.FindAllRegistrations == nil {
			break
		}

		args, err := ec.field_Query_findAllRegistrations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindAllRegistrations(childComplexity, args["filter"].(*table.RegistrationsFilter), args["pagination"].(*internal.Pagination)), true

	case "Query.findAllStudents":
		if e.complexity.Query.FindAllStudents == nil {
			break
		}

		args, err := ec.field_Query_findAllStudents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindAllStudents(childComplexity, args["filter"].(*table.StudentsFilter), args["pagination"].(*internal.Pagination)), true

	case "Query.findAllTrainerTrainingMapping":
		if e.complexity.Query.FindAllTrainerTrainingMapping == nil {
			break
		}

		args, err := ec.field_Query_findAllTrainerTrainingMapping_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindAllTrainerTrainingMapping(childComplexity, args["filter"].(*table.TrainerTrainingMappingFilter), args["pagination"].(*internal.Pagination)), true

	case "Query.findAllTrainers":
		if e.complexity.Query.FindAllTrainers == nil {
			break
		}

		args, err := ec.field_Query_findAllTrainers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindAllTrainers(childComplexity, args["filter"].(*table.TrainersFilter), args["pagination"].(*internal.Pagination)), true

	case "Query.findAllTraining":
		if e.complexity.Query.FindAllTraining == nil {
			break
		}

		args, err := ec.field_Query_findAllTraining_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindAllTraining(childComplexity, args["filter"].(*table.TrainingFilter), args["pagination"].(*internal.Pagination)), true

	case "Query.findAllTrainingEvent":
		if e.complexity.Query.FindAllTrainingEvent == nil {
			break
		}

		args, err := ec.field_Query_findAllTrainingEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindAllTrainingEvent(childComplexity, args["filter"].(*table.TrainingEventFilter), args["pagination"].(*internal.Pagination)), true

	case "Query.findAllUser":
		if e.complexity.Query.FindAllUser == nil {
			break
		}

		args, err := ec.field_Query_findAllUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindAllUser(childComplexity, args["filter"].(*table.UserFilter), args["pagination"].(*internal.Pagination)), true

	case "Query.login":
		if e.complexity.Query.Login == nil {
			break
		}

		args, err := ec.field_Query_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Login(childComplexity, args["email"].(string), args["password"].(string)), true

	case "Registrations.active":
		if e.complexity.Registrations.Active == nil {
			break
		}

		return e.complexity.Registrations.Active(childComplexity), true

	case "Registrations.createdAt":
		if e.complexity.Registrations.CreatedAt == nil {
			break
		}

		return e.complexity.Registrations.CreatedAt(childComplexity), true

	case "Registrations.fkStudent":
		if e.complexity.Registrations.FkStudent == nil {
			break
		}

		return e.complexity.Registrations.FkStudent(childComplexity), true

	case "Registrations.fkTraining":
		if e.complexity.Registrations.FkTraining == nil {
			break
		}

		return e.complexity.Registrations.FkTraining(childComplexity), true

	case "Registrations.id":
		if e.complexity.Registrations.ID == nil {
			break
		}

		return e.complexity.Registrations.ID(childComplexity), true

	case "Registrations.studentsByFkStudent":
		if e.complexity.Registrations.StudentsByFkStudent == nil {
			break
		}

		args, err := ec.field_Registrations_studentsByFkStudent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Registrations.StudentsByFkStudent(childComplexity, args["filter"].(*table.StudentsFilter)), true

	case "Registrations.trainingByFkTraining":
		if e.complexity.Registrations.TrainingByFkTraining == nil {
			break
		}

		args, err := ec.field_Registrations_trainingByFkTraining_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Registrations.TrainingByFkTraining(childComplexity, args["filter"].(*table.TrainingFilter)), true

	case "Registrations.updatedAt":
		if e.complexity.Registrations.UpdatedAt == nil {
			break
		}

		return e.complexity.Registrations.UpdatedAt(childComplexity), true

	case "Students.active":
		if e.complexity.Students.Active == nil {
			break
		}

		return e.complexity.Students.Active(childComplexity), true

	case "Students.attendancesByFkStudent":
		if e.complexity.Students.AttendancesByFkStudent == nil {
			break
		}

		args, err := ec.field_Students_attendancesByFkStudent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Students.AttendancesByFkStudent(childComplexity, args["filter"].(*table.AttendancesFilter), args["pagination"].(*internal.Pagination)), true

	case "Students.className":
		if e.complexity.Students.ClassName == nil {
			break
		}

		return e.complexity.Students.ClassName(childComplexity), true

	case "Students.createdAt":
		if e.complexity.Students.CreatedAt == nil {
			break
		}

		return e.complexity.Students.CreatedAt(childComplexity), true

	case "Students.createdBy":
		if e.complexity.Students.CreatedBy == nil {
			break
		}

		return e.complexity.Students.CreatedBy(childComplexity), true

	case "Students.designation":
		if e.complexity.Students.Designation == nil {
			break
		}

		return e.complexity.Students.Designation(childComplexity), true

	case "Students.email":
		if e.complexity.Students.Email == nil {
			break
		}

		return e.complexity.Students.Email(childComplexity), true

	case "Students.id":
		if e.complexity.Students.ID == nil {
			break
		}

		return e.complexity.Students.ID(childComplexity), true

	case "Students.mobilePhone":
		if e.complexity.Students.MobilePhone == nil {
			break
		}

		return e.complexity.Students.MobilePhone(childComplexity), true

	case "Students.name":
		if e.complexity.Students.Name == nil {
			break
		}

		return e.complexity.Students.Name(childComplexity), true

	case "Students.registrationsByFkStudent":
		if e.complexity.Students.RegistrationsByFkStudent == nil {
			break
		}

		args, err := ec.field_Students_registrationsByFkStudent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Students.RegistrationsByFkStudent(childComplexity, args["filter"].(*table.RegistrationsFilter), args["pagination"].(*internal.Pagination)), true

	case "Students.trainerTrainingMappingByFkStudent":
		if e.complexity.Students.TrainerTrainingMappingByFkStudent == nil {
			break
		}

		args, err := ec.field_Students_trainerTrainingMappingByFkStudent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Students.TrainerTrainingMappingByFkStudent(childComplexity, args["filter"].(*table.TrainerTrainingMappingFilter), args["pagination"].(*internal.Pagination)), true

	case "Students.uuid":
		if e.complexity.Students.UUID == nil {
			break
		}

		return e.complexity.Students.UUID(childComplexity), true

	case "Students.updatedAt":
		if e.complexity.Students.UpdatedAt == nil {
			break
		}

		return e.complexity.Students.UpdatedAt(childComplexity), true

	case "Students.userByCreatedBy":
		if e.complexity.Students.UserByCreatedBy == nil {
			break
		}

		args, err := ec.field_Students_userByCreatedBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Students.UserByCreatedBy(childComplexity, args["filter"].(*table.UserFilter)), true

	case "TrainerTrainingMapping.active":
		if e.complexity.TrainerTrainingMapping.Active == nil {
			break
		}

		return e.complexity.TrainerTrainingMapping.Active(childComplexity), true

	case "TrainerTrainingMapping.createdAt":
		if e.complexity.TrainerTrainingMapping.CreatedAt == nil {
			break
		}

		return e.complexity.TrainerTrainingMapping.CreatedAt(childComplexity), true

	case "TrainerTrainingMapping.fkStudent":
		if e.complexity.TrainerTrainingMapping.FkStudent == nil {
			break
		}

		return e.complexity.TrainerTrainingMapping.FkStudent(childComplexity), true

	case "TrainerTrainingMapping.fkTrainer":
		if e.complexity.TrainerTrainingMapping.FkTrainer == nil {
			break
		}

		return e.complexity.TrainerTrainingMapping.FkTrainer(childComplexity), true

	case "TrainerTrainingMapping.fkTrainingEvent":
		if e.complexity.TrainerTrainingMapping.FkTrainingEvent == nil {
			break
		}

		return e.complexity.TrainerTrainingMapping.FkTrainingEvent(childComplexity), true

	case "TrainerTrainingMapping.id":
		if e.complexity.TrainerTrainingMapping.ID == nil {
			break
		}

		return e.complexity.TrainerTrainingMapping.ID(childComplexity), true

	case "TrainerTrainingMapping.studentsByFkStudent":
		if e.complexity.TrainerTrainingMapping.StudentsByFkStudent == nil {
			break
		}

		args, err := ec.field_TrainerTrainingMapping_studentsByFkStudent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TrainerTrainingMapping.StudentsByFkStudent(childComplexity, args["filter"].(*table.StudentsFilter)), true

	case "TrainerTrainingMapping.trainersByFkTrainer":
		if e.complexity.TrainerTrainingMapping.TrainersByFkTrainer == nil {
			break
		}

		args, err := ec.field_TrainerTrainingMapping_trainersByFkTrainer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TrainerTrainingMapping.TrainersByFkTrainer(childComplexity, args["filter"].(*table.TrainersFilter)), true

	case "TrainerTrainingMapping.trainingEventByFkTrainingEvent":
		if e.complexity.TrainerTrainingMapping.TrainingEventByFkTrainingEvent == nil {
			break
		}

		args, err := ec.field_TrainerTrainingMapping_trainingEventByFkTrainingEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TrainerTrainingMapping.TrainingEventByFkTrainingEvent(childComplexity, args["filter"].(*table.TrainingEventFilter)), true

	case "TrainerTrainingMapping.updatedAt":
		if e.complexity.TrainerTrainingMapping.UpdatedAt == nil {
			break
		}

		return e.complexity.TrainerTrainingMapping.UpdatedAt(childComplexity), true

	case "Trainers.active":
		if e.complexity.Trainers.Active == nil {
			break
		}

		return e.complexity.Trainers.Active(childComplexity), true

	case "Trainers.createdAt":
		if e.complexity.Trainers.CreatedAt == nil {
			break
		}

		return e.complexity.Trainers.CreatedAt(childComplexity), true

	case "Trainers.createdBy":
		if e.complexity.Trainers.CreatedBy == nil {
			break
		}

		return e.complexity.Trainers.CreatedBy(childComplexity), true

	case "Trainers.designation":
		if e.complexity.Trainers.Designation == nil {
			break
		}

		return e.complexity.Trainers.Designation(childComplexity), true

	case "Trainers.email":
		if e.complexity.Trainers.Email == nil {
			break
		}

		return e.complexity.Trainers.Email(childComplexity), true

	case "Trainers.id":
		if e.complexity.Trainers.ID == nil {
			break
		}

		return e.complexity.Trainers.ID(childComplexity), true

	case "Trainers.mobilePhone":
		if e.complexity.Trainers.MobilePhone == nil {
			break
		}

		return e.complexity.Trainers.MobilePhone(childComplexity), true

	case "Trainers.name":
		if e.complexity.Trainers.Name == nil {
			break
		}

		return e.complexity.Trainers.Name(childComplexity), true

	case "Trainers.trainerTrainingMappingByFkTrainer":
		if e.complexity.Trainers.TrainerTrainingMappingByFkTrainer == nil {
			break
		}

		args, err := ec.field_Trainers_trainerTrainingMappingByFkTrainer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Trainers.TrainerTrainingMappingByFkTrainer(childComplexity, args["filter"].(*table.TrainerTrainingMappingFilter), args["pagination"].(*internal.Pagination)), true

	case "Trainers.uuid":
		if e.complexity.Trainers.UUID == nil {
			break
		}

		return e.complexity.Trainers.UUID(childComplexity), true

	case "Trainers.updatedAt":
		if e.complexity.Trainers.UpdatedAt == nil {
			break
		}

		return e.complexity.Trainers.UpdatedAt(childComplexity), true

	case "Trainers.userByCreatedBy":
		if e.complexity.Trainers.UserByCreatedBy == nil {
			break
		}

		args, err := ec.field_Trainers_userByCreatedBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Trainers.UserByCreatedBy(childComplexity, args["filter"].(*table.UserFilter)), true

	case "Training.active":
		if e.complexity.Training.Active == nil {
			break
		}

		return e.complexity.Training.Active(childComplexity), true

	case "Training.createdAt":
		if e.complexity.Training.CreatedAt == nil {
			break
		}

		return e.complexity.Training.CreatedAt(childComplexity), true

	case "Training.createdBy":
		if e.complexity.Training.CreatedBy == nil {
			break
		}

		return e.complexity.Training.CreatedBy(childComplexity), true

	case "Training.id":
		if e.complexity.Training.ID == nil {
			break
		}

		return e.complexity.Training.ID(childComplexity), true

	case "Training.isRegistrationRequired":
		if e.complexity.Training.IsRegistrationRequired == nil {
			break
		}

		return e.complexity.Training.IsRegistrationRequired(childComplexity), true

	case "Training.mode":
		if e.complexity.Training.Mode == nil {
			break
		}

		return e.complexity.Training.Mode(childComplexity), true

	case "Training.registrationsByFkTraining":
		if e.complexity.Training.RegistrationsByFkTraining == nil {
			break
		}

		args, err := ec.field_Training_registrationsByFkTraining_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Training.RegistrationsByFkTraining(childComplexity, args["filter"].(*table.RegistrationsFilter), args["pagination"].(*internal.Pagination)), true

	case "Training.requestedBy":
		if e.complexity.Training.RequestedBy == nil {
			break
		}

		return e.complexity.Training.RequestedBy(childComplexity), true

	case "Training.tags":
		if e.complexity.Training.Tags == nil {
			break
		}

		return e.complexity.Training.Tags(childComplexity), true

	case "Training.trainingEventByFkTraining":
		if e.complexity.Training.TrainingEventByFkTraining == nil {
			break
		}

		args, err := ec.field_Training_trainingEventByFkTraining_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Training.TrainingEventByFkTraining(childComplexity, args["filter"].(*table.TrainingEventFilter), args["pagination"].(*internal.Pagination)), true

	case "Training.trainingName":
		if e.complexity.Training.TrainingName == nil {
			break
		}

		return e.complexity.Training.TrainingName(childComplexity), true

	case "Training.type":
		if e.complexity.Training.Type == nil {
			break
		}

		return e.complexity.Training.Type(childComplexity), true

	case "Training.updatedAt":
		if e.complexity.Training.UpdatedAt == nil {
			break
		}

		return e.complexity.Training.UpdatedAt(childComplexity), true

	case "Training.userByCreatedBy":
		if e.complexity.Training.UserByCreatedBy == nil {
			break
		}

		args, err := ec.field_Training_userByCreatedBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Training.UserByCreatedBy(childComplexity, args["filter"].(*table.UserFilter)), true

	case "Training.userByRequestedBy":
		if e.complexity.Training.UserByRequestedBy == nil {
			break
		}

		args, err := ec.field_Training_userByRequestedBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Training.UserByRequestedBy(childComplexity, args["filter"].(*table.UserFilter)), true

	case "TrainingEvent.active":
		if e.complexity.TrainingEvent.Active == nil {
			break
		}

		return e.complexity.TrainingEvent.Active(childComplexity), true

	case "TrainingEvent.attendancesByFkTrainingEvent":
		if e.complexity.TrainingEvent.AttendancesByFkTrainingEvent == nil {
			break
		}

		args, err := ec.field_TrainingEvent_attendancesByFkTrainingEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TrainingEvent.AttendancesByFkTrainingEvent(childComplexity, args["filter"].(*table.AttendancesFilter), args["pagination"].(*internal.Pagination)), true

	case "TrainingEvent.completedOn":
		if e.complexity.TrainingEvent.CompletedOn == nil {
			break
		}

		return e.complexity.TrainingEvent.CompletedOn(childComplexity), true

	case "TrainingEvent.createdAt":
		if e.complexity.TrainingEvent.CreatedAt == nil {
			break
		}

		return e.complexity.TrainingEvent.CreatedAt(childComplexity), true

	case "TrainingEvent.createdBy":
		if e.complexity.TrainingEvent.CreatedBy == nil {
			break
		}

		return e.complexity.TrainingEvent.CreatedBy(childComplexity), true

	case "TrainingEvent.duration":
		if e.complexity.TrainingEvent.Duration == nil {
			break
		}

		return e.complexity.TrainingEvent.Duration(childComplexity), true

	case "TrainingEvent.fkTraining":
		if e.complexity.TrainingEvent.FkTraining == nil {
			break
		}

		return e.complexity.TrainingEvent.FkTraining(childComplexity), true

	case "TrainingEvent.from":
		if e.complexity.TrainingEvent.From == nil {
			break
		}

		return e.complexity.TrainingEvent.From(childComplexity), true

	case "TrainingEvent.id":
		if e.complexity.TrainingEvent.ID == nil {
			break
		}

		return e.complexity.TrainingEvent.ID(childComplexity), true

	case "TrainingEvent.status":
		if e.complexity.TrainingEvent.Status == nil {
			break
		}

		return e.complexity.TrainingEvent.Status(childComplexity), true

	case "TrainingEvent.trainerTrainingMappingByFkTrainingEvent":
		if e.complexity.TrainingEvent.TrainerTrainingMappingByFkTrainingEvent == nil {
			break
		}

		args, err := ec.field_TrainingEvent_trainerTrainingMappingByFkTrainingEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TrainingEvent.TrainerTrainingMappingByFkTrainingEvent(childComplexity, args["filter"].(*table.TrainerTrainingMappingFilter), args["pagination"].(*internal.Pagination)), true

	case "TrainingEvent.trainingByFkTraining":
		if e.complexity.TrainingEvent.TrainingByFkTraining == nil {
			break
		}

		args, err := ec.field_TrainingEvent_trainingByFkTraining_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TrainingEvent.TrainingByFkTraining(childComplexity, args["filter"].(*table.TrainingFilter)), true

	case "TrainingEvent.updatedAt":
		if e.complexity.TrainingEvent.UpdatedAt == nil {
			break
		}

		return e.complexity.TrainingEvent.UpdatedAt(childComplexity), true

	case "TrainingEvent.userByCreatedBy":
		if e.complexity.TrainingEvent.UserByCreatedBy == nil {
			break
		}

		args, err := ec.field_TrainingEvent_userByCreatedBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TrainingEvent.UserByCreatedBy(childComplexity, args["filter"].(*table.UserFilter)), true

	case "User.active":
		if e.complexity.User.Active == nil {
			break
		}

		return e.complexity.User.Active(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "User.studentsByCreatedBy":
		if e.complexity.User.StudentsByCreatedBy == nil {
			break
		}

		args, err := ec.field_User_studentsByCreatedBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.StudentsByCreatedBy(childComplexity, args["filter"].(*table.StudentsFilter), args["pagination"].(*internal.Pagination)), true

	case "User.trainersByCreatedBy":
		if e.complexity.User.TrainersByCreatedBy == nil {
			break
		}

		args, err := ec.field_User_trainersByCreatedBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TrainersByCreatedBy(childComplexity, args["filter"].(*table.TrainersFilter), args["pagination"].(*internal.Pagination)), true

	case "User.trainingByCreatedBy":
		if e.complexity.User.TrainingByCreatedBy == nil {
			break
		}

		args, err := ec.field_User_trainingByCreatedBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TrainingByCreatedBy(childComplexity, args["filter"].(*table.TrainingFilter), args["pagination"].(*internal.Pagination)), true

	case "User.trainingByRequestedBy":
		if e.complexity.User.TrainingByRequestedBy == nil {
			break
		}

		args, err := ec.field_User_trainingByRequestedBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TrainingByRequestedBy(childComplexity, args["filter"].(*table.TrainingFilter), args["pagination"].(*internal.Pagination)), true

	case "User.trainingEventByCreatedBy":
		if e.complexity.User.TrainingEventByCreatedBy == nil {
			break
		}

		args, err := ec.field_User_trainingEventByCreatedBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TrainingEventByCreatedBy(childComplexity, args["filter"].(*table.TrainingEventFilter), args["pagination"].(*internal.Pagination)), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAttendancesCreate,
		ec.unmarshalInputAttendancesFilter,
		ec.unmarshalInputAttendancesUpdate,
		ec.unmarshalInputPagination,
		ec.unmarshalInputRegistrationsCreate,
		ec.unmarshalInputRegistrationsFilter,
		ec.unmarshalInputRegistrationsUpdate,
		ec.unmarshalInputStudentsCreate,
		ec.unmarshalInputStudentsFilter,
		ec.unmarshalInputStudentsUpdate,
		ec.unmarshalInputTrainerTrainingMappingCreate,
		ec.unmarshalInputTrainerTrainingMappingFilter,
		ec.unmarshalInputTrainerTrainingMappingUpdate,
		ec.unmarshalInputTrainersCreate,
		ec.unmarshalInputTrainersFilter,
		ec.unmarshalInputTrainersUpdate,
		ec.unmarshalInputTrainingCreate,
		ec.unmarshalInputTrainingEventCreate,
		ec.unmarshalInputTrainingEventFilter,
		ec.unmarshalInputTrainingEventUpdate,
		ec.unmarshalInputTrainingFilter,
		ec.unmarshalInputTrainingUpdate,
		ec.unmarshalInputUserCreate,
		ec.unmarshalInputUserFilter,
		ec.unmarshalInputUserUpdate,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/directives.graphql", Input: `directive @authenticate on FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../schema/mutation.graphql", Input: `type Mutation {
    # User
    insertUser(data: UserCreate!): User @authenticate
    updateUserByFields(id: Int!, data: UserUpdate!): User @authenticate
    deleteUserByID(id: Int!): Boolean! @authenticate

    # Trainers
    insertTrainers(data: TrainersCreate!): Trainers @authenticate
    updateTrainersByFields(id: Int!, data: TrainersUpdate!): Trainers @authenticate
    deleteTrainersByID(id: Int!): Boolean! @authenticate

    # Students 
    insertStudents(data: StudentsCreate!): Students @authenticate
    updateStudentsByFields(id: Int!, data: StudentsUpdate!): Students @authenticate
    deleteStudentsByID(id: Int!): Boolean! @authenticate

    # Registrations
    insertRegistrations(data: RegistrationsCreate!): Registrations @authenticate
    updateRegistrationsByFields(id: Int!, data: RegistrationsUpdate!): Registrations @authenticate
    deleteRegistrationsByID(id: Int!): Boolean! @authenticate

    # TrainerTrainingMapping
    insertTrainerTrainingMapping(data: TrainerTrainingMappingCreate!): TrainerTrainingMapping @authenticate
    updateTrainerTrainingMappingByFields(id: Int!, data: TrainerTrainingMappingUpdate!): TrainerTrainingMapping @authenticate
    deleteTrainerTrainingMappingByID(id: Int!): Boolean! @authenticate

    # TrainingEvent
    insertTrainingEvent(data: TrainingEventCreate!): TrainingEvent @authenticate
    updateTrainingEventByFields(id: Int!, data: TrainingEventUpdate!): TrainingEvent @authenticate
    deleteTrainingEventByID(id: Int!): Boolean! @authenticate

    # Training
    insertTraining(data: TrainingCreate!): Training @authenticate
    updateTrainingByFields(id: Int!, data: TrainingUpdate!): Training @authenticate
    deleteTrainingByID(id: Int!): Boolean! @authenticate

}
`, BuiltIn: false},
	{Name: "../schema/pagination.graphql", Input: `# Code generated by Xo. DO NOT EDIT.

input Pagination {
    page: Int
    perPage: Int
    sort: [String!]
}
`, BuiltIn: false},
	{Name: "../schema/query.graphql", Input: `type Query {
    login(email: String!, password: String!): String!
    
    findAllUser(filter: UserFilter, pagination: Pagination): ListUser! @authenticate
    findAllTrainers(filter: TrainersFilter, pagination: Pagination): ListTrainers! @authenticate
    findAllStudents(filter: StudentsFilter, pagination: Pagination): ListStudents! @authenticate
    findAllRegistrations(filter: RegistrationsFilter, pagination: Pagination): ListRegistrations! @authenticate
    findAllTrainerTrainingMapping(filter: TrainerTrainingMappingFilter, pagination: Pagination): ListTrainerTrainingMapping! @authenticate
    findAllTrainingEvent(filter: TrainingEventFilter, pagination: Pagination): ListTrainingEvent! @authenticate
    findAllTraining(filter: TrainingFilter, pagination: Pagination): ListTraining! @authenticate
    
}
`, BuiltIn: false},
	{Name: "../schema/scalar.graphql", Input: `scalar Datetime
scalar IntBool
scalar NullTime
scalar NullInt64
scalar NullFloat64
scalar NullString
scalar NullBool
scalar Map
scalar FilterOnField
`, BuiltIn: false},
	{Name: "../../xo_gen/schema/attendances.graphql", Input: `# Code generated by xo. DO NOT EDIT.

type Attendances {
    id: Int !
    fkTrainingEvent: Int !
    fkStudent: Int !
    active: Boolean !
    createdAt: NullTime 
    updatedAt: NullTime 


    trainingEventByFkTrainingEvent(filter: TrainingEventFilter): TrainingEvent
    studentsByFkStudent(filter: StudentsFilter): Students



}
input AttendancesFilter {
    id: FilterOnField
    fkTrainingEvent: FilterOnField
    fkStudent: FilterOnField
    active: FilterOnField
    createdAt: FilterOnField
    updatedAt: FilterOnField
}

input AttendancesCreate {
    fkTrainingEvent: Int !
    fkStudent: Int !
}

input AttendancesUpdate {
    fkTrainingEvent: Int 
    fkStudent: Int 
    active: Boolean 

}

type ListAttendances {
    totalCount: Int!
    data: [Attendances!]!
}
`, BuiltIn: false},
	{Name: "../../xo_gen/schema/registrations.graphql", Input: `# Code generated by xo. DO NOT EDIT.

type Registrations {
    id: Int !
    fkStudent: Int !
    fkTraining: Int !
    active: Boolean !
    createdAt: NullTime 
    updatedAt: NullTime 


    trainingByFkTraining(filter: TrainingFilter): Training
    studentsByFkStudent(filter: StudentsFilter): Students



}
input RegistrationsFilter {
    id: FilterOnField
    fkStudent: FilterOnField
    fkTraining: FilterOnField
    active: FilterOnField
    createdAt: FilterOnField
    updatedAt: FilterOnField
}

input RegistrationsCreate {
    fkStudent: Int !
    fkTraining: Int !
}

input RegistrationsUpdate {
    fkStudent: Int 
    fkTraining: Int 
    active: Boolean 

}

type ListRegistrations {
    totalCount: Int!
    data: [Registrations!]!
}
`, BuiltIn: false},
	{Name: "../../xo_gen/schema/students.graphql", Input: `# Code generated by xo. DO NOT EDIT.

type Students {
    id: Int !
    uuid: String !
    name: String !
    email: String !
    mobilePhone: String !
    className: String !
    designation: String !
    active: Boolean !
    createdAt: NullTime 
    updatedAt: NullTime 
    createdBy: NullInt64 


    userByCreatedBy(filter: UserFilter): User



    attendancesByFkStudent(filter: AttendancesFilter, pagination: Pagination): ListAttendances!
    registrationsByFkStudent(filter: RegistrationsFilter, pagination: Pagination): ListRegistrations!
    trainerTrainingMappingByFkStudent(filter: TrainerTrainingMappingFilter, pagination: Pagination): ListTrainerTrainingMapping!
}
input StudentsFilter {
    id: FilterOnField
    uuid: FilterOnField
    name: FilterOnField
    email: FilterOnField
    mobilePhone: FilterOnField
    className: FilterOnField
    designation: FilterOnField
    active: FilterOnField
    createdAt: FilterOnField
    updatedAt: FilterOnField
    createdBy: FilterOnField
}

input StudentsCreate {
    uuid: String !
    name: String !
    email: String !
    mobilePhone: String !
    className: String !
    designation: String !
    createdBy: NullInt64 
}

input StudentsUpdate {
    uuid: String 
    name: String 
    email: String 
    mobilePhone: String 
    className: String 
    designation: String 
    active: Boolean 
    createdBy: NullInt64 

}

type ListStudents {
    totalCount: Int!
    data: [Students!]!
}
`, BuiltIn: false},
	{Name: "../../xo_gen/schema/trainer_training_mapping.graphql", Input: `# Code generated by xo. DO NOT EDIT.

type TrainerTrainingMapping {
    id: Int !
    fkTrainingEvent: Int !
    fkTrainer: Int !
    fkStudent: Int !
    active: Boolean !
    createdAt: NullTime 
    updatedAt: NullTime 


    trainingEventByFkTrainingEvent(filter: TrainingEventFilter): TrainingEvent
    trainersByFkTrainer(filter: TrainersFilter): Trainers
    studentsByFkStudent(filter: StudentsFilter): Students



}
input TrainerTrainingMappingFilter {
    id: FilterOnField
    fkTrainingEvent: FilterOnField
    fkTrainer: FilterOnField
    fkStudent: FilterOnField
    active: FilterOnField
    createdAt: FilterOnField
    updatedAt: FilterOnField
}

input TrainerTrainingMappingCreate {
    fkTrainingEvent: Int !
    fkTrainer: Int !
    fkStudent: Int !
}

input TrainerTrainingMappingUpdate {
    fkTrainingEvent: Int 
    fkTrainer: Int 
    fkStudent: Int 
    active: Boolean 

}

type ListTrainerTrainingMapping {
    totalCount: Int!
    data: [TrainerTrainingMapping!]!
}
`, BuiltIn: false},
	{Name: "../../xo_gen/schema/trainers.graphql", Input: `# Code generated by xo. DO NOT EDIT.

type Trainers {
    id: Int !
    uuid: NullString 
    name: String !
    email: String !
    mobilePhone: String !
    designation: String !
    active: Boolean !
    createdAt: NullTime 
    updatedAt: NullTime 
    createdBy: NullInt64 


    userByCreatedBy(filter: UserFilter): User



    trainerTrainingMappingByFkTrainer(filter: TrainerTrainingMappingFilter, pagination: Pagination): ListTrainerTrainingMapping!
}
input TrainersFilter {
    id: FilterOnField
    uuid: FilterOnField
    name: FilterOnField
    email: FilterOnField
    mobilePhone: FilterOnField
    designation: FilterOnField
    active: FilterOnField
    createdAt: FilterOnField
    updatedAt: FilterOnField
    createdBy: FilterOnField
}

input TrainersCreate {
    uuid: NullString 
    name: String !
    email: String !
    mobilePhone: String !
    designation: String !
    createdBy: NullInt64 
}

input TrainersUpdate {
    uuid: NullString 
    name: String 
    email: String 
    mobilePhone: String 
    designation: String 
    active: Boolean 
    createdBy: NullInt64 

}

type ListTrainers {
    totalCount: Int!
    data: [Trainers!]!
}
`, BuiltIn: false},
	{Name: "../../xo_gen/schema/training.graphql", Input: `# Code generated by xo. DO NOT EDIT.

type Training {
    id: Int !
    trainingName: String !
    mode:  TrainingMode 
    type:  TrainingType 
    requestedBy: NullInt64 
    isRegistrationRequired: NullBool 
    tags: NullString 
    active: Boolean !
    createdAt: NullTime 
    updatedAt: NullTime 
    createdBy: NullInt64 


    userByRequestedBy(filter: UserFilter): User
    userByCreatedBy(filter: UserFilter): User



    registrationsByFkTraining(filter: RegistrationsFilter, pagination: Pagination): ListRegistrations!
    trainingEventByFkTraining(filter: TrainingEventFilter, pagination: Pagination): ListTrainingEvent!
}
input TrainingFilter {
    id: FilterOnField
    trainingName: FilterOnField
    mode: FilterOnField
    type: FilterOnField
    requestedBy: FilterOnField
    isRegistrationRequired: FilterOnField
    tags: FilterOnField
    active: FilterOnField
    createdAt: FilterOnField
    updatedAt: FilterOnField
    createdBy: FilterOnField
}

input TrainingCreate {
    trainingName: String !
    mode:  TrainingMode 
    type:  TrainingType 
    requestedBy: NullInt64 
    isRegistrationRequired: NullBool 
    tags: NullString 
    createdBy: NullInt64 
}

input TrainingUpdate {
    trainingName: String 
    mode:  TrainingMode 
    type:  TrainingType 
    requestedBy: NullInt64 
    isRegistrationRequired: NullBool 
    tags: NullString 
    active: Boolean 
    createdBy: NullInt64 

}

type ListTraining {
    totalCount: Int!
    data: [Training!]!
}
`, BuiltIn: false},
	{Name: "../../xo_gen/schema/training_event.graphql", Input: `# Code generated by xo. DO NOT EDIT.

type TrainingEvent {
    id: Int !
    fkTraining: Int !
    status:  TrainingEventStatus !
    from: Datetime !
    completedOn: Datetime !
    duration: NullInt64 
    active: Boolean !
    createdAt: NullTime 
    updatedAt: NullTime 
    createdBy: NullInt64 


    trainingByFkTraining(filter: TrainingFilter): Training
    userByCreatedBy(filter: UserFilter): User



    attendancesByFkTrainingEvent(filter: AttendancesFilter, pagination: Pagination): ListAttendances!
    trainerTrainingMappingByFkTrainingEvent(filter: TrainerTrainingMappingFilter, pagination: Pagination): ListTrainerTrainingMapping!
}
input TrainingEventFilter {
    id: FilterOnField
    fkTraining: FilterOnField
    status: FilterOnField
    from: FilterOnField
    completedOn: FilterOnField
    duration: FilterOnField
    active: FilterOnField
    createdAt: FilterOnField
    updatedAt: FilterOnField
    createdBy: FilterOnField
}

input TrainingEventCreate {
    fkTraining: Int !
    status:  TrainingEventStatus !
    from: Datetime !
    completedOn: Datetime !
    duration: NullInt64 
    createdBy: NullInt64 
}

input TrainingEventUpdate {
    fkTraining: Int 
    status:  TrainingEventStatus 
    from: Datetime 
    completedOn: Datetime 
    duration: NullInt64 
    active: Boolean 
    createdBy: NullInt64 

}

type ListTrainingEvent {
    totalCount: Int!
    data: [TrainingEvent!]!
}
`, BuiltIn: false},
	{Name: "../../xo_gen/schema/user.graphql", Input: `# Code generated by xo. DO NOT EDIT.

type User {
    id: Int !
    name: String !
    email: String !
    password: NullString 
    role:  UserRole 
    active: Boolean !
    createdAt: NullTime 
    updatedAt: NullTime 





    studentsByCreatedBy(filter: StudentsFilter, pagination: Pagination): ListStudents!
    trainersByCreatedBy(filter: TrainersFilter, pagination: Pagination): ListTrainers!
    trainingByRequestedBy(filter: TrainingFilter, pagination: Pagination): ListTraining!
    trainingByCreatedBy(filter: TrainingFilter, pagination: Pagination): ListTraining!
    trainingEventByCreatedBy(filter: TrainingEventFilter, pagination: Pagination): ListTrainingEvent!
}
input UserFilter {
    id: FilterOnField
    name: FilterOnField
    email: FilterOnField
    password: FilterOnField
    role: FilterOnField
    active: FilterOnField
    createdAt: FilterOnField
    updatedAt: FilterOnField
}

input UserCreate {
    name: String !
    email: String !
    password: NullString 
    role:  UserRole 
}

input UserUpdate {
    name: String 
    email: String 
    password: NullString 
    role:  UserRole 
    active: Boolean 

}

type ListUser {
    totalCount: Int!
    data: [User!]!
}
`, BuiltIn: false},
	{Name: "../../xo_gen/scalar.graphql", Input: `# Code generated by xo. DO NOT EDIT.

scalar TrainingMode
scalar TrainingType
scalar TrainingEventStatus
scalar UserRole

`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Attendances_studentsByFkStudent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.StudentsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOStudentsFilter2githubcomketan10trainingbackendxo_gentableStudentsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Attendances_trainingEventByFkTrainingEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainingEventFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainingEventFilter2githubcomketan10trainingbackendxo_gentableTrainingEventFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteRegistrationsByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteStudentsByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTrainerTrainingMappingByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTrainersByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTrainingByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTrainingEventByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUserByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_insertRegistrations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 table.RegistrationsCreate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNRegistrationsCreate2githubcomketan10trainingbackendxo_gentableRegistrationsCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_insertStudents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 table.StudentsCreate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNStudentsCreate2githubcomketan10trainingbackendxo_gentableStudentsCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_insertTrainerTrainingMapping_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 table.TrainerTrainingMappingCreate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNTrainerTrainingMappingCreate2githubcomketan10trainingbackendxo_gentableTrainerTrainingMappingCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_insertTrainers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 table.TrainersCreate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNTrainersCreate2githubcomketan10trainingbackendxo_gentableTrainersCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_insertTrainingEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 table.TrainingEventCreate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNTrainingEventCreate2githubcomketan10trainingbackendxo_gentableTrainingEventCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_insertTraining_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 table.TrainingCreate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNTrainingCreate2githubcomketan10trainingbackendxo_gentableTrainingCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_insertUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 table.UserCreate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNUserCreate2githubcomketan10trainingbackendxo_gentableUserCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRegistrationsByFields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 table.RegistrationsUpdate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg1, err = ec.unmarshalNRegistrationsUpdate2githubcomketan10trainingbackendxo_gentableRegistrationsUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateStudentsByFields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 table.StudentsUpdate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg1, err = ec.unmarshalNStudentsUpdate2githubcomketan10trainingbackendxo_gentableStudentsUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTrainerTrainingMappingByFields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 table.TrainerTrainingMappingUpdate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg1, err = ec.unmarshalNTrainerTrainingMappingUpdate2githubcomketan10trainingbackendxo_gentableTrainerTrainingMappingUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTrainersByFields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 table.TrainersUpdate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg1, err = ec.unmarshalNTrainersUpdate2githubcomketan10trainingbackendxo_gentableTrainersUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTrainingByFields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 table.TrainingUpdate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg1, err = ec.unmarshalNTrainingUpdate2githubcomketan10trainingbackendxo_gentableTrainingUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTrainingEventByFields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 table.TrainingEventUpdate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg1, err = ec.unmarshalNTrainingEventUpdate2githubcomketan10trainingbackendxo_gentableTrainingEventUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserByFields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 table.UserUpdate
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg1, err = ec.unmarshalNUserUpdate2githubcomketan10trainingbackendxo_gentableUserUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findAllRegistrations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.RegistrationsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalORegistrationsFilter2githubcomketan10trainingbackendxo_gentableRegistrationsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_findAllStudents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.StudentsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOStudentsFilter2githubcomketan10trainingbackendxo_gentableStudentsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_findAllTrainerTrainingMapping_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainerTrainingMappingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainerTrainingMappingFilter2githubcomketan10trainingbackendxo_gentableTrainerTrainingMappingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_findAllTrainers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainersFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainersFilter2githubcomketan10trainingbackendxo_gentableTrainersFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_findAllTrainingEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainingEventFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainingEventFilter2githubcomketan10trainingbackendxo_gentableTrainingEventFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_findAllTraining_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainingFilter2githubcomketan10trainingbackendxo_gentableTrainingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_findAllUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.UserFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOUserFilter2githubcomketan10trainingbackendxo_gentableUserFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_login_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["email"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["password"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["password"] = arg1
	return args, nil
}

func (ec *executionContext) field_Registrations_studentsByFkStudent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.StudentsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOStudentsFilter2githubcomketan10trainingbackendxo_gentableStudentsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Registrations_trainingByFkTraining_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainingFilter2githubcomketan10trainingbackendxo_gentableTrainingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Students_attendancesByFkStudent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.AttendancesFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOAttendancesFilter2githubcomketan10trainingbackendxo_gentableAttendancesFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Students_registrationsByFkStudent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.RegistrationsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalORegistrationsFilter2githubcomketan10trainingbackendxo_gentableRegistrationsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Students_trainerTrainingMappingByFkStudent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainerTrainingMappingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainerTrainingMappingFilter2githubcomketan10trainingbackendxo_gentableTrainerTrainingMappingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Students_userByCreatedBy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.UserFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOUserFilter2githubcomketan10trainingbackendxo_gentableUserFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_TrainerTrainingMapping_studentsByFkStudent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.StudentsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOStudentsFilter2githubcomketan10trainingbackendxo_gentableStudentsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_TrainerTrainingMapping_trainersByFkTrainer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainersFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainersFilter2githubcomketan10trainingbackendxo_gentableTrainersFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_TrainerTrainingMapping_trainingEventByFkTrainingEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainingEventFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainingEventFilter2githubcomketan10trainingbackendxo_gentableTrainingEventFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Trainers_trainerTrainingMappingByFkTrainer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainerTrainingMappingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainerTrainingMappingFilter2githubcomketan10trainingbackendxo_gentableTrainerTrainingMappingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Trainers_userByCreatedBy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.UserFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOUserFilter2githubcomketan10trainingbackendxo_gentableUserFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_TrainingEvent_attendancesByFkTrainingEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.AttendancesFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOAttendancesFilter2githubcomketan10trainingbackendxo_gentableAttendancesFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_TrainingEvent_trainerTrainingMappingByFkTrainingEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainerTrainingMappingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainerTrainingMappingFilter2githubcomketan10trainingbackendxo_gentableTrainerTrainingMappingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_TrainingEvent_trainingByFkTraining_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainingFilter2githubcomketan10trainingbackendxo_gentableTrainingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_TrainingEvent_userByCreatedBy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.UserFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOUserFilter2githubcomketan10trainingbackendxo_gentableUserFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Training_registrationsByFkTraining_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.RegistrationsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalORegistrationsFilter2githubcomketan10trainingbackendxo_gentableRegistrationsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Training_trainingEventByFkTraining_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainingEventFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainingEventFilter2githubcomketan10trainingbackendxo_gentableTrainingEventFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Training_userByCreatedBy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.UserFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOUserFilter2githubcomketan10trainingbackendxo_gentableUserFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Training_userByRequestedBy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.UserFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOUserFilter2githubcomketan10trainingbackendxo_gentableUserFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_User_studentsByCreatedBy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.StudentsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOStudentsFilter2githubcomketan10trainingbackendxo_gentableStudentsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_User_trainersByCreatedBy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainersFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainersFilter2githubcomketan10trainingbackendxo_gentableTrainersFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_User_trainingByCreatedBy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainingFilter2githubcomketan10trainingbackendxo_gentableTrainingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_User_trainingByRequestedBy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainingFilter2githubcomketan10trainingbackendxo_gentableTrainingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_User_trainingEventByCreatedBy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *table.TrainingEventFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTrainingEventFilter2githubcomketan10trainingbackendxo_gentableTrainingEventFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *internal.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Attendances_id(ctx context.Context, field graphql.CollectedField, obj *table.Attendances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Attendances_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Attendances_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Attendances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Attendances_fkTrainingEvent(ctx context.Context, field graphql.CollectedField, obj *table.Attendances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Attendances_fkTrainingEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FkTrainingEvent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Attendances_fkTrainingEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Attendances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Attendances_fkStudent(ctx context.Context, field graphql.CollectedField, obj *table.Attendances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Attendances_fkStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FkStudent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Attendances_fkStudent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Attendances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Attendances_active(ctx context.Context, field graphql.CollectedField, obj *table.Attendances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Attendances_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Attendances_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Attendances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Attendances_createdAt(ctx context.Context, field graphql.CollectedField, obj *table.Attendances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Attendances_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Attendances_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Attendances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Attendances_updatedAt(ctx context.Context, field graphql.CollectedField, obj *table.Attendances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Attendances_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Attendances_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Attendances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Attendances_trainingEventByFkTrainingEvent(ctx context.Context, field graphql.CollectedField, obj *table.Attendances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Attendances_trainingEventByFkTrainingEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Attendances().TrainingEventByFkTrainingEvent(rctx, obj, fc.Args["filter"].(*table.TrainingEventFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.TrainingEvent)
	fc.Result = res
	return ec.marshalOTrainingEvent2githubcomketan10trainingbackendxo_gentableTrainingEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Attendances_trainingEventByFkTrainingEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Attendances",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TrainingEvent_id(ctx, field)
			case "fkTraining":
				return ec.fieldContext_TrainingEvent_fkTraining(ctx, field)
			case "status":
				return ec.fieldContext_TrainingEvent_status(ctx, field)
			case "from":
				return ec.fieldContext_TrainingEvent_from(ctx, field)
			case "completedOn":
				return ec.fieldContext_TrainingEvent_completedOn(ctx, field)
			case "duration":
				return ec.fieldContext_TrainingEvent_duration(ctx, field)
			case "active":
				return ec.fieldContext_TrainingEvent_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_TrainingEvent_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TrainingEvent_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_TrainingEvent_createdBy(ctx, field)
			case "trainingByFkTraining":
				return ec.fieldContext_TrainingEvent_trainingByFkTraining(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_TrainingEvent_userByCreatedBy(ctx, field)
			case "attendancesByFkTrainingEvent":
				return ec.fieldContext_TrainingEvent_attendancesByFkTrainingEvent(ctx, field)
			case "trainerTrainingMappingByFkTrainingEvent":
				return ec.fieldContext_TrainingEvent_trainerTrainingMappingByFkTrainingEvent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TrainingEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Attendances_trainingEventByFkTrainingEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Attendances_studentsByFkStudent(ctx context.Context, field graphql.CollectedField, obj *table.Attendances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Attendances_studentsByFkStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Attendances().StudentsByFkStudent(rctx, obj, fc.Args["filter"].(*table.StudentsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Students)
	fc.Result = res
	return ec.marshalOStudents2githubcomketan10trainingbackendxo_gentableStudents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Attendances_studentsByFkStudent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Attendances",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Students_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Students_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Students_name(ctx, field)
			case "email":
				return ec.fieldContext_Students_email(ctx, field)
			case "mobilePhone":
				return ec.fieldContext_Students_mobilePhone(ctx, field)
			case "className":
				return ec.fieldContext_Students_className(ctx, field)
			case "designation":
				return ec.fieldContext_Students_designation(ctx, field)
			case "active":
				return ec.fieldContext_Students_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Students_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Students_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Students_createdBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Students_userByCreatedBy(ctx, field)
			case "attendancesByFkStudent":
				return ec.fieldContext_Students_attendancesByFkStudent(ctx, field)
			case "registrationsByFkStudent":
				return ec.fieldContext_Students_registrationsByFkStudent(ctx, field)
			case "trainerTrainingMappingByFkStudent":
				return ec.fieldContext_Students_trainerTrainingMappingByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Students", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Attendances_studentsByFkStudent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ListAttendances_totalCount(ctx context.Context, field graphql.CollectedField, obj *table.ListAttendances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAttendances_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAttendances_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAttendances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAttendances_data(ctx context.Context, field graphql.CollectedField, obj *table.ListAttendances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAttendances_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]table.Attendances)
	fc.Result = res
	return ec.marshalNAttendances2githubcomketan10trainingbackendxo_gentableAttendances(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAttendances_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAttendances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Attendances_id(ctx, field)
			case "fkTrainingEvent":
				return ec.fieldContext_Attendances_fkTrainingEvent(ctx, field)
			case "fkStudent":
				return ec.fieldContext_Attendances_fkStudent(ctx, field)
			case "active":
				return ec.fieldContext_Attendances_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Attendances_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Attendances_updatedAt(ctx, field)
			case "trainingEventByFkTrainingEvent":
				return ec.fieldContext_Attendances_trainingEventByFkTrainingEvent(ctx, field)
			case "studentsByFkStudent":
				return ec.fieldContext_Attendances_studentsByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Attendances", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListRegistrations_totalCount(ctx context.Context, field graphql.CollectedField, obj *table.ListRegistrations) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListRegistrations_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListRegistrations_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListRegistrations",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListRegistrations_data(ctx context.Context, field graphql.CollectedField, obj *table.ListRegistrations) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListRegistrations_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]table.Registrations)
	fc.Result = res
	return ec.marshalNRegistrations2githubcomketan10trainingbackendxo_gentableRegistrations(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListRegistrations_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListRegistrations",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registrations_id(ctx, field)
			case "fkStudent":
				return ec.fieldContext_Registrations_fkStudent(ctx, field)
			case "fkTraining":
				return ec.fieldContext_Registrations_fkTraining(ctx, field)
			case "active":
				return ec.fieldContext_Registrations_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registrations_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registrations_updatedAt(ctx, field)
			case "trainingByFkTraining":
				return ec.fieldContext_Registrations_trainingByFkTraining(ctx, field)
			case "studentsByFkStudent":
				return ec.fieldContext_Registrations_studentsByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registrations", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListStudents_totalCount(ctx context.Context, field graphql.CollectedField, obj *table.ListStudents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListStudents_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListStudents_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListStudents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListStudents_data(ctx context.Context, field graphql.CollectedField, obj *table.ListStudents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListStudents_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]table.Students)
	fc.Result = res
	return ec.marshalNStudents2githubcomketan10trainingbackendxo_gentableStudents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListStudents_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListStudents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Students_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Students_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Students_name(ctx, field)
			case "email":
				return ec.fieldContext_Students_email(ctx, field)
			case "mobilePhone":
				return ec.fieldContext_Students_mobilePhone(ctx, field)
			case "className":
				return ec.fieldContext_Students_className(ctx, field)
			case "designation":
				return ec.fieldContext_Students_designation(ctx, field)
			case "active":
				return ec.fieldContext_Students_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Students_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Students_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Students_createdBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Students_userByCreatedBy(ctx, field)
			case "attendancesByFkStudent":
				return ec.fieldContext_Students_attendancesByFkStudent(ctx, field)
			case "registrationsByFkStudent":
				return ec.fieldContext_Students_registrationsByFkStudent(ctx, field)
			case "trainerTrainingMappingByFkStudent":
				return ec.fieldContext_Students_trainerTrainingMappingByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Students", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListTrainerTrainingMapping_totalCount(ctx context.Context, field graphql.CollectedField, obj *table.ListTrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListTrainerTrainingMapping_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListTrainerTrainingMapping_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListTrainerTrainingMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListTrainerTrainingMapping_data(ctx context.Context, field graphql.CollectedField, obj *table.ListTrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListTrainerTrainingMapping_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]table.TrainerTrainingMapping)
	fc.Result = res
	return ec.marshalNTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableTrainerTrainingMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListTrainerTrainingMapping_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListTrainerTrainingMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TrainerTrainingMapping_id(ctx, field)
			case "fkTrainingEvent":
				return ec.fieldContext_TrainerTrainingMapping_fkTrainingEvent(ctx, field)
			case "fkTrainer":
				return ec.fieldContext_TrainerTrainingMapping_fkTrainer(ctx, field)
			case "fkStudent":
				return ec.fieldContext_TrainerTrainingMapping_fkStudent(ctx, field)
			case "active":
				return ec.fieldContext_TrainerTrainingMapping_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_TrainerTrainingMapping_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TrainerTrainingMapping_updatedAt(ctx, field)
			case "trainingEventByFkTrainingEvent":
				return ec.fieldContext_TrainerTrainingMapping_trainingEventByFkTrainingEvent(ctx, field)
			case "trainersByFkTrainer":
				return ec.fieldContext_TrainerTrainingMapping_trainersByFkTrainer(ctx, field)
			case "studentsByFkStudent":
				return ec.fieldContext_TrainerTrainingMapping_studentsByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TrainerTrainingMapping", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListTrainers_totalCount(ctx context.Context, field graphql.CollectedField, obj *table.ListTrainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListTrainers_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListTrainers_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListTrainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListTrainers_data(ctx context.Context, field graphql.CollectedField, obj *table.ListTrainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListTrainers_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]table.Trainers)
	fc.Result = res
	return ec.marshalNTrainers2githubcomketan10trainingbackendxo_gentableTrainers(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListTrainers_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListTrainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trainers_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Trainers_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Trainers_name(ctx, field)
			case "email":
				return ec.fieldContext_Trainers_email(ctx, field)
			case "mobilePhone":
				return ec.fieldContext_Trainers_mobilePhone(ctx, field)
			case "designation":
				return ec.fieldContext_Trainers_designation(ctx, field)
			case "active":
				return ec.fieldContext_Trainers_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Trainers_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Trainers_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Trainers_createdBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Trainers_userByCreatedBy(ctx, field)
			case "trainerTrainingMappingByFkTrainer":
				return ec.fieldContext_Trainers_trainerTrainingMappingByFkTrainer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trainers", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListTraining_totalCount(ctx context.Context, field graphql.CollectedField, obj *table.ListTraining) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListTraining_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListTraining_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListTraining",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListTraining_data(ctx context.Context, field graphql.CollectedField, obj *table.ListTraining) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListTraining_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]table.Training)
	fc.Result = res
	return ec.marshalNTraining2githubcomketan10trainingbackendxo_gentableTraining(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListTraining_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListTraining",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Training_id(ctx, field)
			case "trainingName":
				return ec.fieldContext_Training_trainingName(ctx, field)
			case "mode":
				return ec.fieldContext_Training_mode(ctx, field)
			case "type":
				return ec.fieldContext_Training_type(ctx, field)
			case "requestedBy":
				return ec.fieldContext_Training_requestedBy(ctx, field)
			case "isRegistrationRequired":
				return ec.fieldContext_Training_isRegistrationRequired(ctx, field)
			case "tags":
				return ec.fieldContext_Training_tags(ctx, field)
			case "active":
				return ec.fieldContext_Training_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Training_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Training_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Training_createdBy(ctx, field)
			case "userByRequestedBy":
				return ec.fieldContext_Training_userByRequestedBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Training_userByCreatedBy(ctx, field)
			case "registrationsByFkTraining":
				return ec.fieldContext_Training_registrationsByFkTraining(ctx, field)
			case "trainingEventByFkTraining":
				return ec.fieldContext_Training_trainingEventByFkTraining(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Training", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListTrainingEvent_totalCount(ctx context.Context, field graphql.CollectedField, obj *table.ListTrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListTrainingEvent_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListTrainingEvent_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListTrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListTrainingEvent_data(ctx context.Context, field graphql.CollectedField, obj *table.ListTrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListTrainingEvent_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]table.TrainingEvent)
	fc.Result = res
	return ec.marshalNTrainingEvent2githubcomketan10trainingbackendxo_gentableTrainingEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListTrainingEvent_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListTrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TrainingEvent_id(ctx, field)
			case "fkTraining":
				return ec.fieldContext_TrainingEvent_fkTraining(ctx, field)
			case "status":
				return ec.fieldContext_TrainingEvent_status(ctx, field)
			case "from":
				return ec.fieldContext_TrainingEvent_from(ctx, field)
			case "completedOn":
				return ec.fieldContext_TrainingEvent_completedOn(ctx, field)
			case "duration":
				return ec.fieldContext_TrainingEvent_duration(ctx, field)
			case "active":
				return ec.fieldContext_TrainingEvent_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_TrainingEvent_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TrainingEvent_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_TrainingEvent_createdBy(ctx, field)
			case "trainingByFkTraining":
				return ec.fieldContext_TrainingEvent_trainingByFkTraining(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_TrainingEvent_userByCreatedBy(ctx, field)
			case "attendancesByFkTrainingEvent":
				return ec.fieldContext_TrainingEvent_attendancesByFkTrainingEvent(ctx, field)
			case "trainerTrainingMappingByFkTrainingEvent":
				return ec.fieldContext_TrainingEvent_trainerTrainingMappingByFkTrainingEvent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TrainingEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListUser_totalCount(ctx context.Context, field graphql.CollectedField, obj *table.ListUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListUser_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListUser_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListUser_data(ctx context.Context, field graphql.CollectedField, obj *table.ListUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListUser_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]table.User)
	fc.Result = res
	return ec.marshalNUser2githubcomketan10trainingbackendxo_gentableUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListUser_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "active":
				return ec.fieldContext_User_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "studentsByCreatedBy":
				return ec.fieldContext_User_studentsByCreatedBy(ctx, field)
			case "trainersByCreatedBy":
				return ec.fieldContext_User_trainersByCreatedBy(ctx, field)
			case "trainingByRequestedBy":
				return ec.fieldContext_User_trainingByRequestedBy(ctx, field)
			case "trainingByCreatedBy":
				return ec.fieldContext_User_trainingByCreatedBy(ctx, field)
			case "trainingEventByCreatedBy":
				return ec.fieldContext_User_trainingEventByCreatedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_insertUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_insertUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().InsertUser(rctx, fc.Args["data"].(table.UserCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.User)
	fc.Result = res
	return ec.marshalOUser2githubcomketan10trainingbackendxo_gentableUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_insertUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "active":
				return ec.fieldContext_User_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "studentsByCreatedBy":
				return ec.fieldContext_User_studentsByCreatedBy(ctx, field)
			case "trainersByCreatedBy":
				return ec.fieldContext_User_trainersByCreatedBy(ctx, field)
			case "trainingByRequestedBy":
				return ec.fieldContext_User_trainingByRequestedBy(ctx, field)
			case "trainingByCreatedBy":
				return ec.fieldContext_User_trainingByCreatedBy(ctx, field)
			case "trainingEventByCreatedBy":
				return ec.fieldContext_User_trainingEventByCreatedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_insertUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserByFields(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserByFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateUserByFields(rctx, fc.Args["id"].(int), fc.Args["data"].(table.UserUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.User)
	fc.Result = res
	return ec.marshalOUser2githubcomketan10trainingbackendxo_gentableUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserByFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "active":
				return ec.fieldContext_User_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "studentsByCreatedBy":
				return ec.fieldContext_User_studentsByCreatedBy(ctx, field)
			case "trainersByCreatedBy":
				return ec.fieldContext_User_trainersByCreatedBy(ctx, field)
			case "trainingByRequestedBy":
				return ec.fieldContext_User_trainingByRequestedBy(ctx, field)
			case "trainingByCreatedBy":
				return ec.fieldContext_User_trainingByCreatedBy(ctx, field)
			case "trainingEventByCreatedBy":
				return ec.fieldContext_User_trainingEventByCreatedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserByFields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUserByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUserByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteUserByID(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUserByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUserByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_insertTrainers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_insertTrainers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().InsertTrainers(rctx, fc.Args["data"].(table.TrainersCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.Trainers); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.Trainers`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Trainers)
	fc.Result = res
	return ec.marshalOTrainers2githubcomketan10trainingbackendxo_gentableTrainers(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_insertTrainers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trainers_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Trainers_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Trainers_name(ctx, field)
			case "email":
				return ec.fieldContext_Trainers_email(ctx, field)
			case "mobilePhone":
				return ec.fieldContext_Trainers_mobilePhone(ctx, field)
			case "designation":
				return ec.fieldContext_Trainers_designation(ctx, field)
			case "active":
				return ec.fieldContext_Trainers_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Trainers_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Trainers_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Trainers_createdBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Trainers_userByCreatedBy(ctx, field)
			case "trainerTrainingMappingByFkTrainer":
				return ec.fieldContext_Trainers_trainerTrainingMappingByFkTrainer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trainers", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_insertTrainers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTrainersByFields(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTrainersByFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTrainersByFields(rctx, fc.Args["id"].(int), fc.Args["data"].(table.TrainersUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.Trainers); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.Trainers`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Trainers)
	fc.Result = res
	return ec.marshalOTrainers2githubcomketan10trainingbackendxo_gentableTrainers(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTrainersByFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trainers_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Trainers_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Trainers_name(ctx, field)
			case "email":
				return ec.fieldContext_Trainers_email(ctx, field)
			case "mobilePhone":
				return ec.fieldContext_Trainers_mobilePhone(ctx, field)
			case "designation":
				return ec.fieldContext_Trainers_designation(ctx, field)
			case "active":
				return ec.fieldContext_Trainers_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Trainers_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Trainers_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Trainers_createdBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Trainers_userByCreatedBy(ctx, field)
			case "trainerTrainingMappingByFkTrainer":
				return ec.fieldContext_Trainers_trainerTrainingMappingByFkTrainer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trainers", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTrainersByFields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTrainersByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTrainersByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTrainersByID(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTrainersByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTrainersByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_insertStudents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_insertStudents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().InsertStudents(rctx, fc.Args["data"].(table.StudentsCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.Students); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.Students`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Students)
	fc.Result = res
	return ec.marshalOStudents2githubcomketan10trainingbackendxo_gentableStudents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_insertStudents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Students_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Students_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Students_name(ctx, field)
			case "email":
				return ec.fieldContext_Students_email(ctx, field)
			case "mobilePhone":
				return ec.fieldContext_Students_mobilePhone(ctx, field)
			case "className":
				return ec.fieldContext_Students_className(ctx, field)
			case "designation":
				return ec.fieldContext_Students_designation(ctx, field)
			case "active":
				return ec.fieldContext_Students_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Students_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Students_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Students_createdBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Students_userByCreatedBy(ctx, field)
			case "attendancesByFkStudent":
				return ec.fieldContext_Students_attendancesByFkStudent(ctx, field)
			case "registrationsByFkStudent":
				return ec.fieldContext_Students_registrationsByFkStudent(ctx, field)
			case "trainerTrainingMappingByFkStudent":
				return ec.fieldContext_Students_trainerTrainingMappingByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Students", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_insertStudents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateStudentsByFields(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateStudentsByFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateStudentsByFields(rctx, fc.Args["id"].(int), fc.Args["data"].(table.StudentsUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.Students); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.Students`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Students)
	fc.Result = res
	return ec.marshalOStudents2githubcomketan10trainingbackendxo_gentableStudents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateStudentsByFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Students_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Students_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Students_name(ctx, field)
			case "email":
				return ec.fieldContext_Students_email(ctx, field)
			case "mobilePhone":
				return ec.fieldContext_Students_mobilePhone(ctx, field)
			case "className":
				return ec.fieldContext_Students_className(ctx, field)
			case "designation":
				return ec.fieldContext_Students_designation(ctx, field)
			case "active":
				return ec.fieldContext_Students_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Students_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Students_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Students_createdBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Students_userByCreatedBy(ctx, field)
			case "attendancesByFkStudent":
				return ec.fieldContext_Students_attendancesByFkStudent(ctx, field)
			case "registrationsByFkStudent":
				return ec.fieldContext_Students_registrationsByFkStudent(ctx, field)
			case "trainerTrainingMappingByFkStudent":
				return ec.fieldContext_Students_trainerTrainingMappingByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Students", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateStudentsByFields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteStudentsByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteStudentsByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteStudentsByID(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteStudentsByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteStudentsByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_insertRegistrations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_insertRegistrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().InsertRegistrations(rctx, fc.Args["data"].(table.RegistrationsCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.Registrations); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.Registrations`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Registrations)
	fc.Result = res
	return ec.marshalORegistrations2githubcomketan10trainingbackendxo_gentableRegistrations(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_insertRegistrations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registrations_id(ctx, field)
			case "fkStudent":
				return ec.fieldContext_Registrations_fkStudent(ctx, field)
			case "fkTraining":
				return ec.fieldContext_Registrations_fkTraining(ctx, field)
			case "active":
				return ec.fieldContext_Registrations_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registrations_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registrations_updatedAt(ctx, field)
			case "trainingByFkTraining":
				return ec.fieldContext_Registrations_trainingByFkTraining(ctx, field)
			case "studentsByFkStudent":
				return ec.fieldContext_Registrations_studentsByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registrations", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_insertRegistrations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRegistrationsByFields(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRegistrationsByFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateRegistrationsByFields(rctx, fc.Args["id"].(int), fc.Args["data"].(table.RegistrationsUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.Registrations); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.Registrations`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Registrations)
	fc.Result = res
	return ec.marshalORegistrations2githubcomketan10trainingbackendxo_gentableRegistrations(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRegistrationsByFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registrations_id(ctx, field)
			case "fkStudent":
				return ec.fieldContext_Registrations_fkStudent(ctx, field)
			case "fkTraining":
				return ec.fieldContext_Registrations_fkTraining(ctx, field)
			case "active":
				return ec.fieldContext_Registrations_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registrations_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registrations_updatedAt(ctx, field)
			case "trainingByFkTraining":
				return ec.fieldContext_Registrations_trainingByFkTraining(ctx, field)
			case "studentsByFkStudent":
				return ec.fieldContext_Registrations_studentsByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registrations", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRegistrationsByFields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteRegistrationsByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteRegistrationsByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteRegistrationsByID(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteRegistrationsByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteRegistrationsByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_insertTrainerTrainingMapping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_insertTrainerTrainingMapping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().InsertTrainerTrainingMapping(rctx, fc.Args["data"].(table.TrainerTrainingMappingCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.TrainerTrainingMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.TrainerTrainingMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.TrainerTrainingMapping)
	fc.Result = res
	return ec.marshalOTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableTrainerTrainingMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_insertTrainerTrainingMapping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TrainerTrainingMapping_id(ctx, field)
			case "fkTrainingEvent":
				return ec.fieldContext_TrainerTrainingMapping_fkTrainingEvent(ctx, field)
			case "fkTrainer":
				return ec.fieldContext_TrainerTrainingMapping_fkTrainer(ctx, field)
			case "fkStudent":
				return ec.fieldContext_TrainerTrainingMapping_fkStudent(ctx, field)
			case "active":
				return ec.fieldContext_TrainerTrainingMapping_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_TrainerTrainingMapping_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TrainerTrainingMapping_updatedAt(ctx, field)
			case "trainingEventByFkTrainingEvent":
				return ec.fieldContext_TrainerTrainingMapping_trainingEventByFkTrainingEvent(ctx, field)
			case "trainersByFkTrainer":
				return ec.fieldContext_TrainerTrainingMapping_trainersByFkTrainer(ctx, field)
			case "studentsByFkStudent":
				return ec.fieldContext_TrainerTrainingMapping_studentsByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TrainerTrainingMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_insertTrainerTrainingMapping_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTrainerTrainingMappingByFields(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTrainerTrainingMappingByFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTrainerTrainingMappingByFields(rctx, fc.Args["id"].(int), fc.Args["data"].(table.TrainerTrainingMappingUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.TrainerTrainingMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.TrainerTrainingMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.TrainerTrainingMapping)
	fc.Result = res
	return ec.marshalOTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableTrainerTrainingMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTrainerTrainingMappingByFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TrainerTrainingMapping_id(ctx, field)
			case "fkTrainingEvent":
				return ec.fieldContext_TrainerTrainingMapping_fkTrainingEvent(ctx, field)
			case "fkTrainer":
				return ec.fieldContext_TrainerTrainingMapping_fkTrainer(ctx, field)
			case "fkStudent":
				return ec.fieldContext_TrainerTrainingMapping_fkStudent(ctx, field)
			case "active":
				return ec.fieldContext_TrainerTrainingMapping_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_TrainerTrainingMapping_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TrainerTrainingMapping_updatedAt(ctx, field)
			case "trainingEventByFkTrainingEvent":
				return ec.fieldContext_TrainerTrainingMapping_trainingEventByFkTrainingEvent(ctx, field)
			case "trainersByFkTrainer":
				return ec.fieldContext_TrainerTrainingMapping_trainersByFkTrainer(ctx, field)
			case "studentsByFkStudent":
				return ec.fieldContext_TrainerTrainingMapping_studentsByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TrainerTrainingMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTrainerTrainingMappingByFields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTrainerTrainingMappingByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTrainerTrainingMappingByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTrainerTrainingMappingByID(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTrainerTrainingMappingByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTrainerTrainingMappingByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_insertTrainingEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_insertTrainingEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().InsertTrainingEvent(rctx, fc.Args["data"].(table.TrainingEventCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.TrainingEvent); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.TrainingEvent`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.TrainingEvent)
	fc.Result = res
	return ec.marshalOTrainingEvent2githubcomketan10trainingbackendxo_gentableTrainingEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_insertTrainingEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TrainingEvent_id(ctx, field)
			case "fkTraining":
				return ec.fieldContext_TrainingEvent_fkTraining(ctx, field)
			case "status":
				return ec.fieldContext_TrainingEvent_status(ctx, field)
			case "from":
				return ec.fieldContext_TrainingEvent_from(ctx, field)
			case "completedOn":
				return ec.fieldContext_TrainingEvent_completedOn(ctx, field)
			case "duration":
				return ec.fieldContext_TrainingEvent_duration(ctx, field)
			case "active":
				return ec.fieldContext_TrainingEvent_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_TrainingEvent_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TrainingEvent_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_TrainingEvent_createdBy(ctx, field)
			case "trainingByFkTraining":
				return ec.fieldContext_TrainingEvent_trainingByFkTraining(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_TrainingEvent_userByCreatedBy(ctx, field)
			case "attendancesByFkTrainingEvent":
				return ec.fieldContext_TrainingEvent_attendancesByFkTrainingEvent(ctx, field)
			case "trainerTrainingMappingByFkTrainingEvent":
				return ec.fieldContext_TrainingEvent_trainerTrainingMappingByFkTrainingEvent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TrainingEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_insertTrainingEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTrainingEventByFields(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTrainingEventByFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTrainingEventByFields(rctx, fc.Args["id"].(int), fc.Args["data"].(table.TrainingEventUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.TrainingEvent); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.TrainingEvent`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.TrainingEvent)
	fc.Result = res
	return ec.marshalOTrainingEvent2githubcomketan10trainingbackendxo_gentableTrainingEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTrainingEventByFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TrainingEvent_id(ctx, field)
			case "fkTraining":
				return ec.fieldContext_TrainingEvent_fkTraining(ctx, field)
			case "status":
				return ec.fieldContext_TrainingEvent_status(ctx, field)
			case "from":
				return ec.fieldContext_TrainingEvent_from(ctx, field)
			case "completedOn":
				return ec.fieldContext_TrainingEvent_completedOn(ctx, field)
			case "duration":
				return ec.fieldContext_TrainingEvent_duration(ctx, field)
			case "active":
				return ec.fieldContext_TrainingEvent_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_TrainingEvent_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TrainingEvent_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_TrainingEvent_createdBy(ctx, field)
			case "trainingByFkTraining":
				return ec.fieldContext_TrainingEvent_trainingByFkTraining(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_TrainingEvent_userByCreatedBy(ctx, field)
			case "attendancesByFkTrainingEvent":
				return ec.fieldContext_TrainingEvent_attendancesByFkTrainingEvent(ctx, field)
			case "trainerTrainingMappingByFkTrainingEvent":
				return ec.fieldContext_TrainingEvent_trainerTrainingMappingByFkTrainingEvent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TrainingEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTrainingEventByFields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTrainingEventByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTrainingEventByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTrainingEventByID(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTrainingEventByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTrainingEventByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_insertTraining(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_insertTraining(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().InsertTraining(rctx, fc.Args["data"].(table.TrainingCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.Training); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.Training`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Training)
	fc.Result = res
	return ec.marshalOTraining2githubcomketan10trainingbackendxo_gentableTraining(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_insertTraining(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Training_id(ctx, field)
			case "trainingName":
				return ec.fieldContext_Training_trainingName(ctx, field)
			case "mode":
				return ec.fieldContext_Training_mode(ctx, field)
			case "type":
				return ec.fieldContext_Training_type(ctx, field)
			case "requestedBy":
				return ec.fieldContext_Training_requestedBy(ctx, field)
			case "isRegistrationRequired":
				return ec.fieldContext_Training_isRegistrationRequired(ctx, field)
			case "tags":
				return ec.fieldContext_Training_tags(ctx, field)
			case "active":
				return ec.fieldContext_Training_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Training_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Training_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Training_createdBy(ctx, field)
			case "userByRequestedBy":
				return ec.fieldContext_Training_userByRequestedBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Training_userByCreatedBy(ctx, field)
			case "registrationsByFkTraining":
				return ec.fieldContext_Training_registrationsByFkTraining(ctx, field)
			case "trainingEventByFkTraining":
				return ec.fieldContext_Training_trainingEventByFkTraining(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Training", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_insertTraining_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTrainingByFields(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTrainingByFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTrainingByFields(rctx, fc.Args["id"].(int), fc.Args["data"].(table.TrainingUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.Training); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.Training`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Training)
	fc.Result = res
	return ec.marshalOTraining2githubcomketan10trainingbackendxo_gentableTraining(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTrainingByFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Training_id(ctx, field)
			case "trainingName":
				return ec.fieldContext_Training_trainingName(ctx, field)
			case "mode":
				return ec.fieldContext_Training_mode(ctx, field)
			case "type":
				return ec.fieldContext_Training_type(ctx, field)
			case "requestedBy":
				return ec.fieldContext_Training_requestedBy(ctx, field)
			case "isRegistrationRequired":
				return ec.fieldContext_Training_isRegistrationRequired(ctx, field)
			case "tags":
				return ec.fieldContext_Training_tags(ctx, field)
			case "active":
				return ec.fieldContext_Training_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Training_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Training_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Training_createdBy(ctx, field)
			case "userByRequestedBy":
				return ec.fieldContext_Training_userByRequestedBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Training_userByCreatedBy(ctx, field)
			case "registrationsByFkTraining":
				return ec.fieldContext_Training_registrationsByFkTraining(ctx, field)
			case "trainingEventByFkTraining":
				return ec.fieldContext_Training_trainingEventByFkTraining(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Training", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTrainingByFields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTrainingByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTrainingByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTrainingByID(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTrainingByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTrainingByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_login(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Login(rctx, fc.Args["email"].(string), fc.Args["password"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_login_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findAllUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findAllUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindAllUser(rctx, fc.Args["filter"].(*table.UserFilter), fc.Args["pagination"].(*internal.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.ListUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.ListUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListUser)
	fc.Result = res
	return ec.marshalNListUser2githubcomketan10trainingbackendxo_gentableListUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findAllUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListUser_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListUser_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findAllUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findAllTrainers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findAllTrainers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindAllTrainers(rctx, fc.Args["filter"].(*table.TrainersFilter), fc.Args["pagination"].(*internal.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.ListTrainers); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.ListTrainers`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTrainers)
	fc.Result = res
	return ec.marshalNListTrainers2githubcomketan10trainingbackendxo_gentableListTrainers(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findAllTrainers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTrainers_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTrainers_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTrainers", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findAllTrainers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findAllStudents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findAllStudents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindAllStudents(rctx, fc.Args["filter"].(*table.StudentsFilter), fc.Args["pagination"].(*internal.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.ListStudents); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.ListStudents`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListStudents)
	fc.Result = res
	return ec.marshalNListStudents2githubcomketan10trainingbackendxo_gentableListStudents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findAllStudents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListStudents_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListStudents_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListStudents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findAllStudents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findAllRegistrations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findAllRegistrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindAllRegistrations(rctx, fc.Args["filter"].(*table.RegistrationsFilter), fc.Args["pagination"].(*internal.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.ListRegistrations); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.ListRegistrations`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListRegistrations)
	fc.Result = res
	return ec.marshalNListRegistrations2githubcomketan10trainingbackendxo_gentableListRegistrations(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findAllRegistrations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListRegistrations_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListRegistrations_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListRegistrations", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findAllRegistrations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findAllTrainerTrainingMapping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findAllTrainerTrainingMapping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindAllTrainerTrainingMapping(rctx, fc.Args["filter"].(*table.TrainerTrainingMappingFilter), fc.Args["pagination"].(*internal.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.ListTrainerTrainingMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.ListTrainerTrainingMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTrainerTrainingMapping)
	fc.Result = res
	return ec.marshalNListTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableListTrainerTrainingMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findAllTrainerTrainingMapping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTrainerTrainingMapping_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTrainerTrainingMapping_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTrainerTrainingMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findAllTrainerTrainingMapping_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findAllTrainingEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findAllTrainingEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindAllTrainingEvent(rctx, fc.Args["filter"].(*table.TrainingEventFilter), fc.Args["pagination"].(*internal.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.ListTrainingEvent); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.ListTrainingEvent`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTrainingEvent)
	fc.Result = res
	return ec.marshalNListTrainingEvent2githubcomketan10trainingbackendxo_gentableListTrainingEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findAllTrainingEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTrainingEvent_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTrainingEvent_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTrainingEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findAllTrainingEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findAllTraining(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findAllTraining(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindAllTraining(rctx, fc.Args["filter"].(*table.TrainingFilter), fc.Args["pagination"].(*internal.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authenticate == nil {
				return nil, errors.New("directive authenticate is not implemented")
			}
			return ec.directives.Authenticate(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*table.ListTraining); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ketan-10/training/backend/xo_gen/table.ListTraining`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTraining)
	fc.Result = res
	return ec.marshalNListTraining2githubcomketan10trainingbackendxo_gentableListTraining(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findAllTraining(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTraining_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTraining_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTraining", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findAllTraining_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registrations_id(ctx context.Context, field graphql.CollectedField, obj *table.Registrations) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registrations_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registrations_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registrations",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registrations_fkStudent(ctx context.Context, field graphql.CollectedField, obj *table.Registrations) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registrations_fkStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FkStudent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registrations_fkStudent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registrations",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registrations_fkTraining(ctx context.Context, field graphql.CollectedField, obj *table.Registrations) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registrations_fkTraining(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FkTraining, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registrations_fkTraining(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registrations",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registrations_active(ctx context.Context, field graphql.CollectedField, obj *table.Registrations) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registrations_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registrations_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registrations",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registrations_createdAt(ctx context.Context, field graphql.CollectedField, obj *table.Registrations) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registrations_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registrations_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registrations",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registrations_updatedAt(ctx context.Context, field graphql.CollectedField, obj *table.Registrations) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registrations_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registrations_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registrations",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registrations_trainingByFkTraining(ctx context.Context, field graphql.CollectedField, obj *table.Registrations) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registrations_trainingByFkTraining(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Registrations().TrainingByFkTraining(rctx, obj, fc.Args["filter"].(*table.TrainingFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Training)
	fc.Result = res
	return ec.marshalOTraining2githubcomketan10trainingbackendxo_gentableTraining(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registrations_trainingByFkTraining(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registrations",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Training_id(ctx, field)
			case "trainingName":
				return ec.fieldContext_Training_trainingName(ctx, field)
			case "mode":
				return ec.fieldContext_Training_mode(ctx, field)
			case "type":
				return ec.fieldContext_Training_type(ctx, field)
			case "requestedBy":
				return ec.fieldContext_Training_requestedBy(ctx, field)
			case "isRegistrationRequired":
				return ec.fieldContext_Training_isRegistrationRequired(ctx, field)
			case "tags":
				return ec.fieldContext_Training_tags(ctx, field)
			case "active":
				return ec.fieldContext_Training_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Training_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Training_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Training_createdBy(ctx, field)
			case "userByRequestedBy":
				return ec.fieldContext_Training_userByRequestedBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Training_userByCreatedBy(ctx, field)
			case "registrationsByFkTraining":
				return ec.fieldContext_Training_registrationsByFkTraining(ctx, field)
			case "trainingEventByFkTraining":
				return ec.fieldContext_Training_trainingEventByFkTraining(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Training", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Registrations_trainingByFkTraining_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Registrations_studentsByFkStudent(ctx context.Context, field graphql.CollectedField, obj *table.Registrations) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registrations_studentsByFkStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Registrations().StudentsByFkStudent(rctx, obj, fc.Args["filter"].(*table.StudentsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Students)
	fc.Result = res
	return ec.marshalOStudents2githubcomketan10trainingbackendxo_gentableStudents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registrations_studentsByFkStudent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registrations",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Students_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Students_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Students_name(ctx, field)
			case "email":
				return ec.fieldContext_Students_email(ctx, field)
			case "mobilePhone":
				return ec.fieldContext_Students_mobilePhone(ctx, field)
			case "className":
				return ec.fieldContext_Students_className(ctx, field)
			case "designation":
				return ec.fieldContext_Students_designation(ctx, field)
			case "active":
				return ec.fieldContext_Students_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Students_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Students_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Students_createdBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Students_userByCreatedBy(ctx, field)
			case "attendancesByFkStudent":
				return ec.fieldContext_Students_attendancesByFkStudent(ctx, field)
			case "registrationsByFkStudent":
				return ec.fieldContext_Students_registrationsByFkStudent(ctx, field)
			case "trainerTrainingMappingByFkStudent":
				return ec.fieldContext_Students_trainerTrainingMappingByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Students", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Registrations_studentsByFkStudent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Students_id(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_uuid(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_uuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_uuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_name(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_email(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_mobilePhone(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_mobilePhone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MobilePhone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_mobilePhone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_className(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_className(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClassName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_className(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_designation(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_designation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Designation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_designation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_active(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_createdAt(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_updatedAt(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_createdBy(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullInt64)
	fc.Result = res
	return ec.marshalONullInt642databasesqlNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Students_userByCreatedBy(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_userByCreatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Students().UserByCreatedBy(rctx, obj, fc.Args["filter"].(*table.UserFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.User)
	fc.Result = res
	return ec.marshalOUser2githubcomketan10trainingbackendxo_gentableUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_userByCreatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "active":
				return ec.fieldContext_User_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "studentsByCreatedBy":
				return ec.fieldContext_User_studentsByCreatedBy(ctx, field)
			case "trainersByCreatedBy":
				return ec.fieldContext_User_trainersByCreatedBy(ctx, field)
			case "trainingByRequestedBy":
				return ec.fieldContext_User_trainingByRequestedBy(ctx, field)
			case "trainingByCreatedBy":
				return ec.fieldContext_User_trainingByCreatedBy(ctx, field)
			case "trainingEventByCreatedBy":
				return ec.fieldContext_User_trainingEventByCreatedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Students_userByCreatedBy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Students_attendancesByFkStudent(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_attendancesByFkStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Students().AttendancesByFkStudent(rctx, obj, fc.Args["filter"].(*table.AttendancesFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListAttendances)
	fc.Result = res
	return ec.marshalNListAttendances2githubcomketan10trainingbackendxo_gentableListAttendances(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_attendancesByFkStudent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListAttendances_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListAttendances_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListAttendances", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Students_attendancesByFkStudent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Students_registrationsByFkStudent(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_registrationsByFkStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Students().RegistrationsByFkStudent(rctx, obj, fc.Args["filter"].(*table.RegistrationsFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListRegistrations)
	fc.Result = res
	return ec.marshalNListRegistrations2githubcomketan10trainingbackendxo_gentableListRegistrations(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_registrationsByFkStudent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListRegistrations_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListRegistrations_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListRegistrations", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Students_registrationsByFkStudent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Students_trainerTrainingMappingByFkStudent(ctx context.Context, field graphql.CollectedField, obj *table.Students) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Students_trainerTrainingMappingByFkStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Students().TrainerTrainingMappingByFkStudent(rctx, obj, fc.Args["filter"].(*table.TrainerTrainingMappingFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTrainerTrainingMapping)
	fc.Result = res
	return ec.marshalNListTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableListTrainerTrainingMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Students_trainerTrainingMappingByFkStudent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Students",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTrainerTrainingMapping_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTrainerTrainingMapping_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTrainerTrainingMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Students_trainerTrainingMappingByFkStudent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TrainerTrainingMapping_id(ctx context.Context, field graphql.CollectedField, obj *table.TrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainerTrainingMapping_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainerTrainingMapping_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainerTrainingMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainerTrainingMapping_fkTrainingEvent(ctx context.Context, field graphql.CollectedField, obj *table.TrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainerTrainingMapping_fkTrainingEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FkTrainingEvent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainerTrainingMapping_fkTrainingEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainerTrainingMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainerTrainingMapping_fkTrainer(ctx context.Context, field graphql.CollectedField, obj *table.TrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainerTrainingMapping_fkTrainer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FkTrainer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainerTrainingMapping_fkTrainer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainerTrainingMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainerTrainingMapping_fkStudent(ctx context.Context, field graphql.CollectedField, obj *table.TrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainerTrainingMapping_fkStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FkStudent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainerTrainingMapping_fkStudent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainerTrainingMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainerTrainingMapping_active(ctx context.Context, field graphql.CollectedField, obj *table.TrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainerTrainingMapping_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainerTrainingMapping_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainerTrainingMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainerTrainingMapping_createdAt(ctx context.Context, field graphql.CollectedField, obj *table.TrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainerTrainingMapping_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainerTrainingMapping_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainerTrainingMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainerTrainingMapping_updatedAt(ctx context.Context, field graphql.CollectedField, obj *table.TrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainerTrainingMapping_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainerTrainingMapping_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainerTrainingMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainerTrainingMapping_trainingEventByFkTrainingEvent(ctx context.Context, field graphql.CollectedField, obj *table.TrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainerTrainingMapping_trainingEventByFkTrainingEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TrainerTrainingMapping().TrainingEventByFkTrainingEvent(rctx, obj, fc.Args["filter"].(*table.TrainingEventFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.TrainingEvent)
	fc.Result = res
	return ec.marshalOTrainingEvent2githubcomketan10trainingbackendxo_gentableTrainingEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainerTrainingMapping_trainingEventByFkTrainingEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainerTrainingMapping",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TrainingEvent_id(ctx, field)
			case "fkTraining":
				return ec.fieldContext_TrainingEvent_fkTraining(ctx, field)
			case "status":
				return ec.fieldContext_TrainingEvent_status(ctx, field)
			case "from":
				return ec.fieldContext_TrainingEvent_from(ctx, field)
			case "completedOn":
				return ec.fieldContext_TrainingEvent_completedOn(ctx, field)
			case "duration":
				return ec.fieldContext_TrainingEvent_duration(ctx, field)
			case "active":
				return ec.fieldContext_TrainingEvent_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_TrainingEvent_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TrainingEvent_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_TrainingEvent_createdBy(ctx, field)
			case "trainingByFkTraining":
				return ec.fieldContext_TrainingEvent_trainingByFkTraining(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_TrainingEvent_userByCreatedBy(ctx, field)
			case "attendancesByFkTrainingEvent":
				return ec.fieldContext_TrainingEvent_attendancesByFkTrainingEvent(ctx, field)
			case "trainerTrainingMappingByFkTrainingEvent":
				return ec.fieldContext_TrainingEvent_trainerTrainingMappingByFkTrainingEvent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TrainingEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TrainerTrainingMapping_trainingEventByFkTrainingEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TrainerTrainingMapping_trainersByFkTrainer(ctx context.Context, field graphql.CollectedField, obj *table.TrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainerTrainingMapping_trainersByFkTrainer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TrainerTrainingMapping().TrainersByFkTrainer(rctx, obj, fc.Args["filter"].(*table.TrainersFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Trainers)
	fc.Result = res
	return ec.marshalOTrainers2githubcomketan10trainingbackendxo_gentableTrainers(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainerTrainingMapping_trainersByFkTrainer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainerTrainingMapping",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trainers_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Trainers_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Trainers_name(ctx, field)
			case "email":
				return ec.fieldContext_Trainers_email(ctx, field)
			case "mobilePhone":
				return ec.fieldContext_Trainers_mobilePhone(ctx, field)
			case "designation":
				return ec.fieldContext_Trainers_designation(ctx, field)
			case "active":
				return ec.fieldContext_Trainers_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Trainers_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Trainers_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Trainers_createdBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Trainers_userByCreatedBy(ctx, field)
			case "trainerTrainingMappingByFkTrainer":
				return ec.fieldContext_Trainers_trainerTrainingMappingByFkTrainer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trainers", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TrainerTrainingMapping_trainersByFkTrainer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TrainerTrainingMapping_studentsByFkStudent(ctx context.Context, field graphql.CollectedField, obj *table.TrainerTrainingMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainerTrainingMapping_studentsByFkStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TrainerTrainingMapping().StudentsByFkStudent(rctx, obj, fc.Args["filter"].(*table.StudentsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Students)
	fc.Result = res
	return ec.marshalOStudents2githubcomketan10trainingbackendxo_gentableStudents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainerTrainingMapping_studentsByFkStudent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainerTrainingMapping",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Students_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Students_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Students_name(ctx, field)
			case "email":
				return ec.fieldContext_Students_email(ctx, field)
			case "mobilePhone":
				return ec.fieldContext_Students_mobilePhone(ctx, field)
			case "className":
				return ec.fieldContext_Students_className(ctx, field)
			case "designation":
				return ec.fieldContext_Students_designation(ctx, field)
			case "active":
				return ec.fieldContext_Students_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Students_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Students_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Students_createdBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Students_userByCreatedBy(ctx, field)
			case "attendancesByFkStudent":
				return ec.fieldContext_Students_attendancesByFkStudent(ctx, field)
			case "registrationsByFkStudent":
				return ec.fieldContext_Students_registrationsByFkStudent(ctx, field)
			case "trainerTrainingMappingByFkStudent":
				return ec.fieldContext_Students_trainerTrainingMappingByFkStudent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Students", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TrainerTrainingMapping_studentsByFkStudent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_id(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_uuid(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_uuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullString)
	fc.Result = res
	return ec.marshalONullString2databasesqlNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_uuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_name(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_email(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_mobilePhone(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_mobilePhone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MobilePhone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_mobilePhone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_designation(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_designation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Designation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_designation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_active(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_createdAt(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_updatedAt(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_createdBy(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullInt64)
	fc.Result = res
	return ec.marshalONullInt642databasesqlNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_userByCreatedBy(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_userByCreatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trainers().UserByCreatedBy(rctx, obj, fc.Args["filter"].(*table.UserFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.User)
	fc.Result = res
	return ec.marshalOUser2githubcomketan10trainingbackendxo_gentableUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_userByCreatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "active":
				return ec.fieldContext_User_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "studentsByCreatedBy":
				return ec.fieldContext_User_studentsByCreatedBy(ctx, field)
			case "trainersByCreatedBy":
				return ec.fieldContext_User_trainersByCreatedBy(ctx, field)
			case "trainingByRequestedBy":
				return ec.fieldContext_User_trainingByRequestedBy(ctx, field)
			case "trainingByCreatedBy":
				return ec.fieldContext_User_trainingByCreatedBy(ctx, field)
			case "trainingEventByCreatedBy":
				return ec.fieldContext_User_trainingEventByCreatedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Trainers_userByCreatedBy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Trainers_trainerTrainingMappingByFkTrainer(ctx context.Context, field graphql.CollectedField, obj *table.Trainers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trainers_trainerTrainingMappingByFkTrainer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trainers().TrainerTrainingMappingByFkTrainer(rctx, obj, fc.Args["filter"].(*table.TrainerTrainingMappingFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTrainerTrainingMapping)
	fc.Result = res
	return ec.marshalNListTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableListTrainerTrainingMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trainers_trainerTrainingMappingByFkTrainer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trainers",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTrainerTrainingMapping_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTrainerTrainingMapping_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTrainerTrainingMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Trainers_trainerTrainingMappingByFkTrainer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Training_id(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_trainingName(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_trainingName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TrainingName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_trainingName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_mode(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*enum.TrainingMode)
	fc.Result = res
	return ec.marshalOTrainingMode2githubcomketan10trainingbackendxo_genenumTrainingMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_mode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TrainingMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_type(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*enum.TrainingType)
	fc.Result = res
	return ec.marshalOTrainingType2githubcomketan10trainingbackendxo_genenumTrainingType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TrainingType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_requestedBy(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_requestedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullInt64)
	fc.Result = res
	return ec.marshalONullInt642databasesqlNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_requestedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_isRegistrationRequired(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_isRegistrationRequired(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRegistrationRequired, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullBool)
	fc.Result = res
	return ec.marshalONullBool2databasesqlNullBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_isRegistrationRequired(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullBool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_tags(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullString)
	fc.Result = res
	return ec.marshalONullString2databasesqlNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_active(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_createdAt(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_updatedAt(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_createdBy(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullInt64)
	fc.Result = res
	return ec.marshalONullInt642databasesqlNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Training_userByRequestedBy(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_userByRequestedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Training().UserByRequestedBy(rctx, obj, fc.Args["filter"].(*table.UserFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.User)
	fc.Result = res
	return ec.marshalOUser2githubcomketan10trainingbackendxo_gentableUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_userByRequestedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "active":
				return ec.fieldContext_User_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "studentsByCreatedBy":
				return ec.fieldContext_User_studentsByCreatedBy(ctx, field)
			case "trainersByCreatedBy":
				return ec.fieldContext_User_trainersByCreatedBy(ctx, field)
			case "trainingByRequestedBy":
				return ec.fieldContext_User_trainingByRequestedBy(ctx, field)
			case "trainingByCreatedBy":
				return ec.fieldContext_User_trainingByCreatedBy(ctx, field)
			case "trainingEventByCreatedBy":
				return ec.fieldContext_User_trainingEventByCreatedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Training_userByRequestedBy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Training_userByCreatedBy(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_userByCreatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Training().UserByCreatedBy(rctx, obj, fc.Args["filter"].(*table.UserFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.User)
	fc.Result = res
	return ec.marshalOUser2githubcomketan10trainingbackendxo_gentableUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_userByCreatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "active":
				return ec.fieldContext_User_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "studentsByCreatedBy":
				return ec.fieldContext_User_studentsByCreatedBy(ctx, field)
			case "trainersByCreatedBy":
				return ec.fieldContext_User_trainersByCreatedBy(ctx, field)
			case "trainingByRequestedBy":
				return ec.fieldContext_User_trainingByRequestedBy(ctx, field)
			case "trainingByCreatedBy":
				return ec.fieldContext_User_trainingByCreatedBy(ctx, field)
			case "trainingEventByCreatedBy":
				return ec.fieldContext_User_trainingEventByCreatedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Training_userByCreatedBy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Training_registrationsByFkTraining(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_registrationsByFkTraining(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Training().RegistrationsByFkTraining(rctx, obj, fc.Args["filter"].(*table.RegistrationsFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListRegistrations)
	fc.Result = res
	return ec.marshalNListRegistrations2githubcomketan10trainingbackendxo_gentableListRegistrations(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_registrationsByFkTraining(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListRegistrations_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListRegistrations_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListRegistrations", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Training_registrationsByFkTraining_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Training_trainingEventByFkTraining(ctx context.Context, field graphql.CollectedField, obj *table.Training) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Training_trainingEventByFkTraining(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Training().TrainingEventByFkTraining(rctx, obj, fc.Args["filter"].(*table.TrainingEventFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTrainingEvent)
	fc.Result = res
	return ec.marshalNListTrainingEvent2githubcomketan10trainingbackendxo_gentableListTrainingEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Training_trainingEventByFkTraining(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Training",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTrainingEvent_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTrainingEvent_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTrainingEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Training_trainingEventByFkTraining_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_id(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_fkTraining(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_fkTraining(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FkTraining, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_fkTraining(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_status(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(enum.TrainingEventStatus)
	fc.Result = res
	return ec.marshalNTrainingEventStatus2githubcomketan10trainingbackendxo_genenumTrainingEventStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TrainingEventStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_from(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_from(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.From, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDatetime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_from(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Datetime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_completedOn(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_completedOn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedOn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDatetime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_completedOn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Datetime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_duration(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullInt64)
	fc.Result = res
	return ec.marshalONullInt642databasesqlNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_active(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_createdAt(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_updatedAt(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_createdBy(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullInt64)
	fc.Result = res
	return ec.marshalONullInt642databasesqlNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_trainingByFkTraining(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_trainingByFkTraining(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TrainingEvent().TrainingByFkTraining(rctx, obj, fc.Args["filter"].(*table.TrainingFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.Training)
	fc.Result = res
	return ec.marshalOTraining2githubcomketan10trainingbackendxo_gentableTraining(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_trainingByFkTraining(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Training_id(ctx, field)
			case "trainingName":
				return ec.fieldContext_Training_trainingName(ctx, field)
			case "mode":
				return ec.fieldContext_Training_mode(ctx, field)
			case "type":
				return ec.fieldContext_Training_type(ctx, field)
			case "requestedBy":
				return ec.fieldContext_Training_requestedBy(ctx, field)
			case "isRegistrationRequired":
				return ec.fieldContext_Training_isRegistrationRequired(ctx, field)
			case "tags":
				return ec.fieldContext_Training_tags(ctx, field)
			case "active":
				return ec.fieldContext_Training_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_Training_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Training_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Training_createdBy(ctx, field)
			case "userByRequestedBy":
				return ec.fieldContext_Training_userByRequestedBy(ctx, field)
			case "userByCreatedBy":
				return ec.fieldContext_Training_userByCreatedBy(ctx, field)
			case "registrationsByFkTraining":
				return ec.fieldContext_Training_registrationsByFkTraining(ctx, field)
			case "trainingEventByFkTraining":
				return ec.fieldContext_Training_trainingEventByFkTraining(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Training", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TrainingEvent_trainingByFkTraining_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_userByCreatedBy(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_userByCreatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TrainingEvent().UserByCreatedBy(rctx, obj, fc.Args["filter"].(*table.UserFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*table.User)
	fc.Result = res
	return ec.marshalOUser2githubcomketan10trainingbackendxo_gentableUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_userByCreatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "active":
				return ec.fieldContext_User_active(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "studentsByCreatedBy":
				return ec.fieldContext_User_studentsByCreatedBy(ctx, field)
			case "trainersByCreatedBy":
				return ec.fieldContext_User_trainersByCreatedBy(ctx, field)
			case "trainingByRequestedBy":
				return ec.fieldContext_User_trainingByRequestedBy(ctx, field)
			case "trainingByCreatedBy":
				return ec.fieldContext_User_trainingByCreatedBy(ctx, field)
			case "trainingEventByCreatedBy":
				return ec.fieldContext_User_trainingEventByCreatedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TrainingEvent_userByCreatedBy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_attendancesByFkTrainingEvent(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_attendancesByFkTrainingEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TrainingEvent().AttendancesByFkTrainingEvent(rctx, obj, fc.Args["filter"].(*table.AttendancesFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListAttendances)
	fc.Result = res
	return ec.marshalNListAttendances2githubcomketan10trainingbackendxo_gentableListAttendances(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_attendancesByFkTrainingEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListAttendances_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListAttendances_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListAttendances", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TrainingEvent_attendancesByFkTrainingEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TrainingEvent_trainerTrainingMappingByFkTrainingEvent(ctx context.Context, field graphql.CollectedField, obj *table.TrainingEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingEvent_trainerTrainingMappingByFkTrainingEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TrainingEvent().TrainerTrainingMappingByFkTrainingEvent(rctx, obj, fc.Args["filter"].(*table.TrainerTrainingMappingFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTrainerTrainingMapping)
	fc.Result = res
	return ec.marshalNListTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableListTrainerTrainingMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingEvent_trainerTrainingMappingByFkTrainingEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingEvent",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTrainerTrainingMapping_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTrainerTrainingMapping_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTrainerTrainingMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TrainingEvent_trainerTrainingMappingByFkTrainingEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_password(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_password(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullString)
	fc.Result = res
	return ec.marshalONullString2databasesqlNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_password(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_role(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*enum.UserRole)
	fc.Result = res
	return ec.marshalOUserRole2githubcomketan10trainingbackendxo_genenumUserRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_active(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updatedAt(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(sql.NullTime)
	fc.Result = res
	return ec.marshalONullTime2databasesqlNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_studentsByCreatedBy(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_studentsByCreatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().StudentsByCreatedBy(rctx, obj, fc.Args["filter"].(*table.StudentsFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListStudents)
	fc.Result = res
	return ec.marshalNListStudents2githubcomketan10trainingbackendxo_gentableListStudents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_studentsByCreatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListStudents_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListStudents_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListStudents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_studentsByCreatedBy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_trainersByCreatedBy(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_trainersByCreatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().TrainersByCreatedBy(rctx, obj, fc.Args["filter"].(*table.TrainersFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTrainers)
	fc.Result = res
	return ec.marshalNListTrainers2githubcomketan10trainingbackendxo_gentableListTrainers(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_trainersByCreatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTrainers_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTrainers_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTrainers", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_trainersByCreatedBy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_trainingByRequestedBy(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_trainingByRequestedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().TrainingByRequestedBy(rctx, obj, fc.Args["filter"].(*table.TrainingFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTraining)
	fc.Result = res
	return ec.marshalNListTraining2githubcomketan10trainingbackendxo_gentableListTraining(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_trainingByRequestedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTraining_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTraining_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTraining", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_trainingByRequestedBy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_trainingByCreatedBy(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_trainingByCreatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().TrainingByCreatedBy(rctx, obj, fc.Args["filter"].(*table.TrainingFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTraining)
	fc.Result = res
	return ec.marshalNListTraining2githubcomketan10trainingbackendxo_gentableListTraining(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_trainingByCreatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTraining_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTraining_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTraining", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_trainingByCreatedBy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_trainingEventByCreatedBy(ctx context.Context, field graphql.CollectedField, obj *table.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_trainingEventByCreatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().TrainingEventByCreatedBy(rctx, obj, fc.Args["filter"].(*table.TrainingEventFilter), fc.Args["pagination"].(*internal.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*table.ListTrainingEvent)
	fc.Result = res
	return ec.marshalNListTrainingEvent2githubcomketan10trainingbackendxo_gentableListTrainingEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_trainingEventByCreatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListTrainingEvent_totalCount(ctx, field)
			case "data":
				return ec.fieldContext_ListTrainingEvent_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTrainingEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_trainingEventByCreatedBy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAttendancesCreate(ctx context.Context, obj interface{}) (table.AttendancesCreate, error) {
	var it table.AttendancesCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fkTrainingEvent", "fkStudent"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fkTrainingEvent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTrainingEvent"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTrainingEvent = data
		case "fkStudent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkStudent"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkStudent = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAttendancesFilter(ctx context.Context, obj interface{}) (table.AttendancesFilter, error) {
	var it table.AttendancesFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "fkTrainingEvent", "fkStudent", "active", "createdAt", "updatedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "fkTrainingEvent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTrainingEvent"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTrainingEvent = data
		case "fkStudent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkStudent"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkStudent = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAttendancesUpdate(ctx context.Context, obj interface{}) (table.AttendancesUpdate, error) {
	var it table.AttendancesUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fkTrainingEvent", "fkStudent", "active"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fkTrainingEvent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTrainingEvent"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTrainingEvent = data
		case "fkStudent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkStudent"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkStudent = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPagination(ctx context.Context, obj interface{}) (internal.Pagination, error) {
	var it internal.Pagination
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"page", "perPage", "sort"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "perPage":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perPage"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerPage = data
		case "sort":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegistrationsCreate(ctx context.Context, obj interface{}) (table.RegistrationsCreate, error) {
	var it table.RegistrationsCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fkStudent", "fkTraining"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fkStudent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkStudent"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkStudent = data
		case "fkTraining":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTraining"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTraining = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegistrationsFilter(ctx context.Context, obj interface{}) (table.RegistrationsFilter, error) {
	var it table.RegistrationsFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "fkStudent", "fkTraining", "active", "createdAt", "updatedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "fkStudent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkStudent"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkStudent = data
		case "fkTraining":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTraining"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTraining = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegistrationsUpdate(ctx context.Context, obj interface{}) (table.RegistrationsUpdate, error) {
	var it table.RegistrationsUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fkStudent", "fkTraining", "active"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fkStudent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkStudent"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkStudent = data
		case "fkTraining":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTraining"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTraining = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStudentsCreate(ctx context.Context, obj interface{}) (table.StudentsCreate, error) {
	var it table.StudentsCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"uuid", "name", "email", "mobilePhone", "className", "designation", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "uuid":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UUID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "mobilePhone":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobilePhone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MobilePhone = data
		case "className":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("className"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClassName = data
		case "designation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("designation"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Designation = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStudentsFilter(ctx context.Context, obj interface{}) (table.StudentsFilter, error) {
	var it table.StudentsFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "uuid", "name", "email", "mobilePhone", "className", "designation", "active", "createdAt", "updatedAt", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "uuid":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.UUID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "mobilePhone":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobilePhone"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.MobilePhone = data
		case "className":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("className"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClassName = data
		case "designation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("designation"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Designation = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStudentsUpdate(ctx context.Context, obj interface{}) (table.StudentsUpdate, error) {
	var it table.StudentsUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"uuid", "name", "email", "mobilePhone", "className", "designation", "active", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "uuid":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UUID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "mobilePhone":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobilePhone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MobilePhone = data
		case "className":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("className"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClassName = data
		case "designation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("designation"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Designation = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainerTrainingMappingCreate(ctx context.Context, obj interface{}) (table.TrainerTrainingMappingCreate, error) {
	var it table.TrainerTrainingMappingCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fkTrainingEvent", "fkTrainer", "fkStudent"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fkTrainingEvent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTrainingEvent"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTrainingEvent = data
		case "fkTrainer":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTrainer"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTrainer = data
		case "fkStudent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkStudent"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkStudent = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainerTrainingMappingFilter(ctx context.Context, obj interface{}) (table.TrainerTrainingMappingFilter, error) {
	var it table.TrainerTrainingMappingFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "fkTrainingEvent", "fkTrainer", "fkStudent", "active", "createdAt", "updatedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "fkTrainingEvent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTrainingEvent"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTrainingEvent = data
		case "fkTrainer":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTrainer"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTrainer = data
		case "fkStudent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkStudent"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkStudent = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainerTrainingMappingUpdate(ctx context.Context, obj interface{}) (table.TrainerTrainingMappingUpdate, error) {
	var it table.TrainerTrainingMappingUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fkTrainingEvent", "fkTrainer", "fkStudent", "active"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fkTrainingEvent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTrainingEvent"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTrainingEvent = data
		case "fkTrainer":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTrainer"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTrainer = data
		case "fkStudent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkStudent"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkStudent = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainersCreate(ctx context.Context, obj interface{}) (table.TrainersCreate, error) {
	var it table.TrainersCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"uuid", "name", "email", "mobilePhone", "designation", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "uuid":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
			data, err := ec.unmarshalONullString2databasesqlNullString(ctx, v)
			if err != nil {
				return it, err
			}
			it.UUID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "mobilePhone":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobilePhone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MobilePhone = data
		case "designation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("designation"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Designation = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainersFilter(ctx context.Context, obj interface{}) (table.TrainersFilter, error) {
	var it table.TrainersFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "uuid", "name", "email", "mobilePhone", "designation", "active", "createdAt", "updatedAt", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "uuid":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.UUID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "mobilePhone":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobilePhone"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.MobilePhone = data
		case "designation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("designation"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Designation = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainersUpdate(ctx context.Context, obj interface{}) (table.TrainersUpdate, error) {
	var it table.TrainersUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"uuid", "name", "email", "mobilePhone", "designation", "active", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "uuid":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
			data, err := ec.unmarshalONullString2databasesqlNullString(ctx, v)
			if err != nil {
				return it, err
			}
			it.UUID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "mobilePhone":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobilePhone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MobilePhone = data
		case "designation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("designation"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Designation = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainingCreate(ctx context.Context, obj interface{}) (table.TrainingCreate, error) {
	var it table.TrainingCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"trainingName", "mode", "type", "requestedBy", "isRegistrationRequired", "tags", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "trainingName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trainingName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TrainingName = data
		case "mode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalOTrainingMode2githubcomketan10trainingbackendxo_genenumTrainingMode(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOTrainingType2githubcomketan10trainingbackendxo_genenumTrainingType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "requestedBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestedBy"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequestedBy = data
		case "isRegistrationRequired":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isRegistrationRequired"))
			data, err := ec.unmarshalONullBool2databasesqlNullBool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsRegistrationRequired = data
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalONullString2databasesqlNullString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainingEventCreate(ctx context.Context, obj interface{}) (table.TrainingEventCreate, error) {
	var it table.TrainingEventCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fkTraining", "status", "from", "completedOn", "duration", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fkTraining":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTraining"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTraining = data
		case "status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalNTrainingEventStatus2githubcomketan10trainingbackendxo_genenumTrainingEventStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "from":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			data, err := ec.unmarshalNDatetime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.From = data
		case "completedOn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("completedOn"))
			data, err := ec.unmarshalNDatetime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompletedOn = data
		case "duration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainingEventFilter(ctx context.Context, obj interface{}) (table.TrainingEventFilter, error) {
	var it table.TrainingEventFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "fkTraining", "status", "from", "completedOn", "duration", "active", "createdAt", "updatedAt", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "fkTraining":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTraining"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTraining = data
		case "status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "from":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.From = data
		case "completedOn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("completedOn"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompletedOn = data
		case "duration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainingEventUpdate(ctx context.Context, obj interface{}) (table.TrainingEventUpdate, error) {
	var it table.TrainingEventUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fkTraining", "status", "from", "completedOn", "duration", "active", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fkTraining":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fkTraining"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FkTraining = data
		case "status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOTrainingEventStatus2githubcomketan10trainingbackendxo_genenumTrainingEventStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "from":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			data, err := ec.unmarshalODatetime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.From = data
		case "completedOn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("completedOn"))
			data, err := ec.unmarshalODatetime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompletedOn = data
		case "duration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainingFilter(ctx context.Context, obj interface{}) (table.TrainingFilter, error) {
	var it table.TrainingFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "trainingName", "mode", "type", "requestedBy", "isRegistrationRequired", "tags", "active", "createdAt", "updatedAt", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "trainingName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trainingName"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.TrainingName = data
		case "mode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "requestedBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestedBy"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequestedBy = data
		case "isRegistrationRequired":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isRegistrationRequired"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsRegistrationRequired = data
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainingUpdate(ctx context.Context, obj interface{}) (table.TrainingUpdate, error) {
	var it table.TrainingUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"trainingName", "mode", "type", "requestedBy", "isRegistrationRequired", "tags", "active", "createdBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "trainingName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trainingName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TrainingName = data
		case "mode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalOTrainingMode2githubcomketan10trainingbackendxo_genenumTrainingMode(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOTrainingType2githubcomketan10trainingbackendxo_genenumTrainingType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "requestedBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestedBy"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequestedBy = data
		case "isRegistrationRequired":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isRegistrationRequired"))
			data, err := ec.unmarshalONullBool2databasesqlNullBool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsRegistrationRequired = data
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalONullString2databasesqlNullString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalONullInt642databasesqlNullInt64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserCreate(ctx context.Context, obj interface{}) (table.UserCreate, error) {
	var it table.UserCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "email", "password", "role"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "password":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalONullString2databasesqlNullString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOUserRole2githubcomketan10trainingbackendxo_genenumUserRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserFilter(ctx context.Context, obj interface{}) (table.UserFilter, error) {
	var it table.UserFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "email", "password", "role", "active", "createdAt", "updatedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "password":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserUpdate(ctx context.Context, obj interface{}) (table.UserUpdate, error) {
	var it table.UserUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "email", "password", "role", "active"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "password":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalONullString2databasesqlNullString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOUserRole2githubcomketan10trainingbackendxo_genenumUserRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var attendancesImplementors = []string{"Attendances"}

func (ec *executionContext) _Attendances(ctx context.Context, sel ast.SelectionSet, obj *table.Attendances) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attendancesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Attendances")
		case "id":
			out.Values[i] = ec._Attendances_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fkTrainingEvent":
			out.Values[i] = ec._Attendances_fkTrainingEvent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fkStudent":
			out.Values[i] = ec._Attendances_fkStudent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "active":
			out.Values[i] = ec._Attendances_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Attendances_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Attendances_updatedAt(ctx, field, obj)
		case "trainingEventByFkTrainingEvent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Attendances_trainingEventByFkTrainingEvent(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "studentsByFkStudent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Attendances_studentsByFkStudent(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listAttendancesImplementors = []string{"ListAttendances"}

func (ec *executionContext) _ListAttendances(ctx context.Context, sel ast.SelectionSet, obj *table.ListAttendances) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listAttendancesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListAttendances")
		case "totalCount":
			out.Values[i] = ec._ListAttendances_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._ListAttendances_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listRegistrationsImplementors = []string{"ListRegistrations"}

func (ec *executionContext) _ListRegistrations(ctx context.Context, sel ast.SelectionSet, obj *table.ListRegistrations) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listRegistrationsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListRegistrations")
		case "totalCount":
			out.Values[i] = ec._ListRegistrations_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._ListRegistrations_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listStudentsImplementors = []string{"ListStudents"}

func (ec *executionContext) _ListStudents(ctx context.Context, sel ast.SelectionSet, obj *table.ListStudents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listStudentsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListStudents")
		case "totalCount":
			out.Values[i] = ec._ListStudents_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._ListStudents_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listTrainerTrainingMappingImplementors = []string{"ListTrainerTrainingMapping"}

func (ec *executionContext) _ListTrainerTrainingMapping(ctx context.Context, sel ast.SelectionSet, obj *table.ListTrainerTrainingMapping) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listTrainerTrainingMappingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListTrainerTrainingMapping")
		case "totalCount":
			out.Values[i] = ec._ListTrainerTrainingMapping_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._ListTrainerTrainingMapping_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listTrainersImplementors = []string{"ListTrainers"}

func (ec *executionContext) _ListTrainers(ctx context.Context, sel ast.SelectionSet, obj *table.ListTrainers) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listTrainersImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListTrainers")
		case "totalCount":
			out.Values[i] = ec._ListTrainers_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._ListTrainers_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listTrainingImplementors = []string{"ListTraining"}

func (ec *executionContext) _ListTraining(ctx context.Context, sel ast.SelectionSet, obj *table.ListTraining) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listTrainingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListTraining")
		case "totalCount":
			out.Values[i] = ec._ListTraining_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._ListTraining_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listTrainingEventImplementors = []string{"ListTrainingEvent"}

func (ec *executionContext) _ListTrainingEvent(ctx context.Context, sel ast.SelectionSet, obj *table.ListTrainingEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listTrainingEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListTrainingEvent")
		case "totalCount":
			out.Values[i] = ec._ListTrainingEvent_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._ListTrainingEvent_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listUserImplementors = []string{"ListUser"}

func (ec *executionContext) _ListUser(ctx context.Context, sel ast.SelectionSet, obj *table.ListUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListUser")
		case "totalCount":
			out.Values[i] = ec._ListUser_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._ListUser_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "insertUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_insertUser(ctx, field)
			})
		case "updateUserByFields":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserByFields(ctx, field)
			})
		case "deleteUserByID":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUserByID(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "insertTrainers":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_insertTrainers(ctx, field)
			})
		case "updateTrainersByFields":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTrainersByFields(ctx, field)
			})
		case "deleteTrainersByID":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTrainersByID(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "insertStudents":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_insertStudents(ctx, field)
			})
		case "updateStudentsByFields":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateStudentsByFields(ctx, field)
			})
		case "deleteStudentsByID":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteStudentsByID(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "insertRegistrations":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_insertRegistrations(ctx, field)
			})
		case "updateRegistrationsByFields":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRegistrationsByFields(ctx, field)
			})
		case "deleteRegistrationsByID":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteRegistrationsByID(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "insertTrainerTrainingMapping":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_insertTrainerTrainingMapping(ctx, field)
			})
		case "updateTrainerTrainingMappingByFields":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTrainerTrainingMappingByFields(ctx, field)
			})
		case "deleteTrainerTrainingMappingByID":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTrainerTrainingMappingByID(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "insertTrainingEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_insertTrainingEvent(ctx, field)
			})
		case "updateTrainingEventByFields":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTrainingEventByFields(ctx, field)
			})
		case "deleteTrainingEventByID":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTrainingEventByID(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "insertTraining":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_insertTraining(ctx, field)
			})
		case "updateTrainingByFields":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTrainingByFields(ctx, field)
			})
		case "deleteTrainingByID":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTrainingByID(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "login":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_login(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findAllUser":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findAllUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findAllTrainers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findAllTrainers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findAllStudents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findAllStudents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findAllRegistrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findAllRegistrations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findAllTrainerTrainingMapping":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findAllTrainerTrainingMapping(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findAllTrainingEvent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findAllTrainingEvent(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findAllTraining":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findAllTraining(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var registrationsImplementors = []string{"Registrations"}

func (ec *executionContext) _Registrations(ctx context.Context, sel ast.SelectionSet, obj *table.Registrations) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registrationsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Registrations")
		case "id":
			out.Values[i] = ec._Registrations_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fkStudent":
			out.Values[i] = ec._Registrations_fkStudent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fkTraining":
			out.Values[i] = ec._Registrations_fkTraining(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "active":
			out.Values[i] = ec._Registrations_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Registrations_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Registrations_updatedAt(ctx, field, obj)
		case "trainingByFkTraining":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Registrations_trainingByFkTraining(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "studentsByFkStudent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Registrations_studentsByFkStudent(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var studentsImplementors = []string{"Students"}

func (ec *executionContext) _Students(ctx context.Context, sel ast.SelectionSet, obj *table.Students) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, studentsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Students")
		case "id":
			out.Values[i] = ec._Students_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "uuid":
			out.Values[i] = ec._Students_uuid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Students_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._Students_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mobilePhone":
			out.Values[i] = ec._Students_mobilePhone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "className":
			out.Values[i] = ec._Students_className(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "designation":
			out.Values[i] = ec._Students_designation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "active":
			out.Values[i] = ec._Students_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Students_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Students_updatedAt(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._Students_createdBy(ctx, field, obj)
		case "userByCreatedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Students_userByCreatedBy(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "attendancesByFkStudent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Students_attendancesByFkStudent(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "registrationsByFkStudent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Students_registrationsByFkStudent(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trainerTrainingMappingByFkStudent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Students_trainerTrainingMappingByFkStudent(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var trainerTrainingMappingImplementors = []string{"TrainerTrainingMapping"}

func (ec *executionContext) _TrainerTrainingMapping(ctx context.Context, sel ast.SelectionSet, obj *table.TrainerTrainingMapping) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, trainerTrainingMappingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TrainerTrainingMapping")
		case "id":
			out.Values[i] = ec._TrainerTrainingMapping_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fkTrainingEvent":
			out.Values[i] = ec._TrainerTrainingMapping_fkTrainingEvent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fkTrainer":
			out.Values[i] = ec._TrainerTrainingMapping_fkTrainer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fkStudent":
			out.Values[i] = ec._TrainerTrainingMapping_fkStudent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "active":
			out.Values[i] = ec._TrainerTrainingMapping_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._TrainerTrainingMapping_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._TrainerTrainingMapping_updatedAt(ctx, field, obj)
		case "trainingEventByFkTrainingEvent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TrainerTrainingMapping_trainingEventByFkTrainingEvent(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trainersByFkTrainer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TrainerTrainingMapping_trainersByFkTrainer(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "studentsByFkStudent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TrainerTrainingMapping_studentsByFkStudent(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var trainersImplementors = []string{"Trainers"}

func (ec *executionContext) _Trainers(ctx context.Context, sel ast.SelectionSet, obj *table.Trainers) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, trainersImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Trainers")
		case "id":
			out.Values[i] = ec._Trainers_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "uuid":
			out.Values[i] = ec._Trainers_uuid(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Trainers_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._Trainers_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mobilePhone":
			out.Values[i] = ec._Trainers_mobilePhone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "designation":
			out.Values[i] = ec._Trainers_designation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "active":
			out.Values[i] = ec._Trainers_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Trainers_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Trainers_updatedAt(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._Trainers_createdBy(ctx, field, obj)
		case "userByCreatedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trainers_userByCreatedBy(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trainerTrainingMappingByFkTrainer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trainers_trainerTrainingMappingByFkTrainer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var trainingImplementors = []string{"Training"}

func (ec *executionContext) _Training(ctx context.Context, sel ast.SelectionSet, obj *table.Training) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, trainingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Training")
		case "id":
			out.Values[i] = ec._Training_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "trainingName":
			out.Values[i] = ec._Training_trainingName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mode":
			out.Values[i] = ec._Training_mode(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Training_type(ctx, field, obj)
		case "requestedBy":
			out.Values[i] = ec._Training_requestedBy(ctx, field, obj)
		case "isRegistrationRequired":
			out.Values[i] = ec._Training_isRegistrationRequired(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._Training_tags(ctx, field, obj)
		case "active":
			out.Values[i] = ec._Training_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Training_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Training_updatedAt(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._Training_createdBy(ctx, field, obj)
		case "userByRequestedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Training_userByRequestedBy(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userByCreatedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Training_userByCreatedBy(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "registrationsByFkTraining":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Training_registrationsByFkTraining(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trainingEventByFkTraining":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Training_trainingEventByFkTraining(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var trainingEventImplementors = []string{"TrainingEvent"}

func (ec *executionContext) _TrainingEvent(ctx context.Context, sel ast.SelectionSet, obj *table.TrainingEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, trainingEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TrainingEvent")
		case "id":
			out.Values[i] = ec._TrainingEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fkTraining":
			out.Values[i] = ec._TrainingEvent_fkTraining(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._TrainingEvent_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "from":
			out.Values[i] = ec._TrainingEvent_from(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "completedOn":
			out.Values[i] = ec._TrainingEvent_completedOn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "duration":
			out.Values[i] = ec._TrainingEvent_duration(ctx, field, obj)
		case "active":
			out.Values[i] = ec._TrainingEvent_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._TrainingEvent_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._TrainingEvent_updatedAt(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._TrainingEvent_createdBy(ctx, field, obj)
		case "trainingByFkTraining":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TrainingEvent_trainingByFkTraining(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userByCreatedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TrainingEvent_userByCreatedBy(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "attendancesByFkTrainingEvent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TrainingEvent_attendancesByFkTrainingEvent(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trainerTrainingMappingByFkTrainingEvent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TrainingEvent_trainerTrainingMappingByFkTrainingEvent(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *table.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "password":
			out.Values[i] = ec._User_password(ctx, field, obj)
		case "role":
			out.Values[i] = ec._User_role(ctx, field, obj)
		case "active":
			out.Values[i] = ec._User_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._User_updatedAt(ctx, field, obj)
		case "studentsByCreatedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_studentsByCreatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trainersByCreatedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_trainersByCreatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trainingByRequestedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_trainingByRequestedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trainingByCreatedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_trainingByCreatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trainingEventByCreatedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_trainingEventByCreatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAttendances2githubcomketan10trainingbackendxo_gentableAttendances(ctx context.Context, sel ast.SelectionSet, v table.Attendances) graphql.Marshaler {
	return ec._Attendances(ctx, sel, &v)
}

func (ec *executionContext) marshalNAttendances2githubcomketan10trainingbackendxo_gentableAttendances(ctx context.Context, sel ast.SelectionSet, v []table.Attendances) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAttendances2githubcomketan10trainingbackendxo_gentableAttendances(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDatetime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := internal.UnmarshalDatetime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDatetime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := internal.MarshalDatetime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNListAttendances2githubcomketan10trainingbackendxo_gentableListAttendances(ctx context.Context, sel ast.SelectionSet, v table.ListAttendances) graphql.Marshaler {
	return ec._ListAttendances(ctx, sel, &v)
}

func (ec *executionContext) marshalNListAttendances2githubcomketan10trainingbackendxo_gentableListAttendances(ctx context.Context, sel ast.SelectionSet, v *table.ListAttendances) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListAttendances(ctx, sel, v)
}

func (ec *executionContext) marshalNListRegistrations2githubcomketan10trainingbackendxo_gentableListRegistrations(ctx context.Context, sel ast.SelectionSet, v table.ListRegistrations) graphql.Marshaler {
	return ec._ListRegistrations(ctx, sel, &v)
}

func (ec *executionContext) marshalNListRegistrations2githubcomketan10trainingbackendxo_gentableListRegistrations(ctx context.Context, sel ast.SelectionSet, v *table.ListRegistrations) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListRegistrations(ctx, sel, v)
}

func (ec *executionContext) marshalNListStudents2githubcomketan10trainingbackendxo_gentableListStudents(ctx context.Context, sel ast.SelectionSet, v table.ListStudents) graphql.Marshaler {
	return ec._ListStudents(ctx, sel, &v)
}

func (ec *executionContext) marshalNListStudents2githubcomketan10trainingbackendxo_gentableListStudents(ctx context.Context, sel ast.SelectionSet, v *table.ListStudents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListStudents(ctx, sel, v)
}

func (ec *executionContext) marshalNListTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableListTrainerTrainingMapping(ctx context.Context, sel ast.SelectionSet, v table.ListTrainerTrainingMapping) graphql.Marshaler {
	return ec._ListTrainerTrainingMapping(ctx, sel, &v)
}

func (ec *executionContext) marshalNListTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableListTrainerTrainingMapping(ctx context.Context, sel ast.SelectionSet, v *table.ListTrainerTrainingMapping) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListTrainerTrainingMapping(ctx, sel, v)
}

func (ec *executionContext) marshalNListTrainers2githubcomketan10trainingbackendxo_gentableListTrainers(ctx context.Context, sel ast.SelectionSet, v table.ListTrainers) graphql.Marshaler {
	return ec._ListTrainers(ctx, sel, &v)
}

func (ec *executionContext) marshalNListTrainers2githubcomketan10trainingbackendxo_gentableListTrainers(ctx context.Context, sel ast.SelectionSet, v *table.ListTrainers) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListTrainers(ctx, sel, v)
}

func (ec *executionContext) marshalNListTraining2githubcomketan10trainingbackendxo_gentableListTraining(ctx context.Context, sel ast.SelectionSet, v table.ListTraining) graphql.Marshaler {
	return ec._ListTraining(ctx, sel, &v)
}

func (ec *executionContext) marshalNListTraining2githubcomketan10trainingbackendxo_gentableListTraining(ctx context.Context, sel ast.SelectionSet, v *table.ListTraining) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListTraining(ctx, sel, v)
}

func (ec *executionContext) marshalNListTrainingEvent2githubcomketan10trainingbackendxo_gentableListTrainingEvent(ctx context.Context, sel ast.SelectionSet, v table.ListTrainingEvent) graphql.Marshaler {
	return ec._ListTrainingEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNListTrainingEvent2githubcomketan10trainingbackendxo_gentableListTrainingEvent(ctx context.Context, sel ast.SelectionSet, v *table.ListTrainingEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListTrainingEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNListUser2githubcomketan10trainingbackendxo_gentableListUser(ctx context.Context, sel ast.SelectionSet, v table.ListUser) graphql.Marshaler {
	return ec._ListUser(ctx, sel, &v)
}

func (ec *executionContext) marshalNListUser2githubcomketan10trainingbackendxo_gentableListUser(ctx context.Context, sel ast.SelectionSet, v *table.ListUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListUser(ctx, sel, v)
}

func (ec *executionContext) marshalNRegistrations2githubcomketan10trainingbackendxo_gentableRegistrations(ctx context.Context, sel ast.SelectionSet, v table.Registrations) graphql.Marshaler {
	return ec._Registrations(ctx, sel, &v)
}

func (ec *executionContext) marshalNRegistrations2githubcomketan10trainingbackendxo_gentableRegistrations(ctx context.Context, sel ast.SelectionSet, v []table.Registrations) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRegistrations2githubcomketan10trainingbackendxo_gentableRegistrations(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNRegistrationsCreate2githubcomketan10trainingbackendxo_gentableRegistrationsCreate(ctx context.Context, v interface{}) (table.RegistrationsCreate, error) {
	res, err := ec.unmarshalInputRegistrationsCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRegistrationsUpdate2githubcomketan10trainingbackendxo_gentableRegistrationsUpdate(ctx context.Context, v interface{}) (table.RegistrationsUpdate, error) {
	res, err := ec.unmarshalInputRegistrationsUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNStudents2githubcomketan10trainingbackendxo_gentableStudents(ctx context.Context, sel ast.SelectionSet, v table.Students) graphql.Marshaler {
	return ec._Students(ctx, sel, &v)
}

func (ec *executionContext) marshalNStudents2githubcomketan10trainingbackendxo_gentableStudents(ctx context.Context, sel ast.SelectionSet, v []table.Students) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStudents2githubcomketan10trainingbackendxo_gentableStudents(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNStudentsCreate2githubcomketan10trainingbackendxo_gentableStudentsCreate(ctx context.Context, v interface{}) (table.StudentsCreate, error) {
	res, err := ec.unmarshalInputStudentsCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNStudentsUpdate2githubcomketan10trainingbackendxo_gentableStudentsUpdate(ctx context.Context, v interface{}) (table.StudentsUpdate, error) {
	res, err := ec.unmarshalInputStudentsUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableTrainerTrainingMapping(ctx context.Context, sel ast.SelectionSet, v table.TrainerTrainingMapping) graphql.Marshaler {
	return ec._TrainerTrainingMapping(ctx, sel, &v)
}

func (ec *executionContext) marshalNTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableTrainerTrainingMapping(ctx context.Context, sel ast.SelectionSet, v []table.TrainerTrainingMapping) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableTrainerTrainingMapping(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTrainerTrainingMappingCreate2githubcomketan10trainingbackendxo_gentableTrainerTrainingMappingCreate(ctx context.Context, v interface{}) (table.TrainerTrainingMappingCreate, error) {
	res, err := ec.unmarshalInputTrainerTrainingMappingCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTrainerTrainingMappingUpdate2githubcomketan10trainingbackendxo_gentableTrainerTrainingMappingUpdate(ctx context.Context, v interface{}) (table.TrainerTrainingMappingUpdate, error) {
	res, err := ec.unmarshalInputTrainerTrainingMappingUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTrainers2githubcomketan10trainingbackendxo_gentableTrainers(ctx context.Context, sel ast.SelectionSet, v table.Trainers) graphql.Marshaler {
	return ec._Trainers(ctx, sel, &v)
}

func (ec *executionContext) marshalNTrainers2githubcomketan10trainingbackendxo_gentableTrainers(ctx context.Context, sel ast.SelectionSet, v []table.Trainers) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrainers2githubcomketan10trainingbackendxo_gentableTrainers(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTrainersCreate2githubcomketan10trainingbackendxo_gentableTrainersCreate(ctx context.Context, v interface{}) (table.TrainersCreate, error) {
	res, err := ec.unmarshalInputTrainersCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTrainersUpdate2githubcomketan10trainingbackendxo_gentableTrainersUpdate(ctx context.Context, v interface{}) (table.TrainersUpdate, error) {
	res, err := ec.unmarshalInputTrainersUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTraining2githubcomketan10trainingbackendxo_gentableTraining(ctx context.Context, sel ast.SelectionSet, v table.Training) graphql.Marshaler {
	return ec._Training(ctx, sel, &v)
}

func (ec *executionContext) marshalNTraining2githubcomketan10trainingbackendxo_gentableTraining(ctx context.Context, sel ast.SelectionSet, v []table.Training) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTraining2githubcomketan10trainingbackendxo_gentableTraining(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTrainingCreate2githubcomketan10trainingbackendxo_gentableTrainingCreate(ctx context.Context, v interface{}) (table.TrainingCreate, error) {
	res, err := ec.unmarshalInputTrainingCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTrainingEvent2githubcomketan10trainingbackendxo_gentableTrainingEvent(ctx context.Context, sel ast.SelectionSet, v table.TrainingEvent) graphql.Marshaler {
	return ec._TrainingEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNTrainingEvent2githubcomketan10trainingbackendxo_gentableTrainingEvent(ctx context.Context, sel ast.SelectionSet, v []table.TrainingEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrainingEvent2githubcomketan10trainingbackendxo_gentableTrainingEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTrainingEventCreate2githubcomketan10trainingbackendxo_gentableTrainingEventCreate(ctx context.Context, v interface{}) (table.TrainingEventCreate, error) {
	res, err := ec.unmarshalInputTrainingEventCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTrainingEventStatus2githubcomketan10trainingbackendxo_genenumTrainingEventStatus(ctx context.Context, v interface{}) (enum.TrainingEventStatus, error) {
	var res enum.TrainingEventStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTrainingEventStatus2githubcomketan10trainingbackendxo_genenumTrainingEventStatus(ctx context.Context, sel ast.SelectionSet, v enum.TrainingEventStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTrainingEventUpdate2githubcomketan10trainingbackendxo_gentableTrainingEventUpdate(ctx context.Context, v interface{}) (table.TrainingEventUpdate, error) {
	res, err := ec.unmarshalInputTrainingEventUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTrainingUpdate2githubcomketan10trainingbackendxo_gentableTrainingUpdate(ctx context.Context, v interface{}) (table.TrainingUpdate, error) {
	res, err := ec.unmarshalInputTrainingUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubcomketan10trainingbackendxo_gentableUser(ctx context.Context, sel ast.SelectionSet, v table.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomketan10trainingbackendxo_gentableUser(ctx context.Context, sel ast.SelectionSet, v []table.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubcomketan10trainingbackendxo_gentableUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUserCreate2githubcomketan10trainingbackendxo_gentableUserCreate(ctx context.Context, v interface{}) (table.UserCreate, error) {
	res, err := ec.unmarshalInputUserCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserUpdate2githubcomketan10trainingbackendxo_gentableUserUpdate(ctx context.Context, v interface{}) (table.UserUpdate, error) {
	res, err := ec.unmarshalInputUserUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAttendancesFilter2githubcomketan10trainingbackendxo_gentableAttendancesFilter(ctx context.Context, v interface{}) (*table.AttendancesFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAttendancesFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalODatetime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := internal.UnmarshalDatetime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODatetime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := internal.MarshalDatetime(*v)
	return res
}

func (ec *executionContext) unmarshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx context.Context, v interface{}) (internal.FilterOnField, error) {
	if v == nil {
		return nil, nil
	}
	var res internal.FilterOnField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFilterOnField2githubcomketan10trainingbackendinternalFilterOnField(ctx context.Context, sel ast.SelectionSet, v internal.FilterOnField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalONullBool2databasesqlNullBool(ctx context.Context, v interface{}) (sql.NullBool, error) {
	res, err := internal.UnmarshalNullBool(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONullBool2databasesqlNullBool(ctx context.Context, sel ast.SelectionSet, v sql.NullBool) graphql.Marshaler {
	res := internal.MarshalNullBool(v)
	return res
}

func (ec *executionContext) unmarshalONullBool2databasesqlNullBool(ctx context.Context, v interface{}) (*sql.NullBool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := internal.UnmarshalNullBool(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONullBool2databasesqlNullBool(ctx context.Context, sel ast.SelectionSet, v *sql.NullBool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := internal.MarshalNullBool(*v)
	return res
}

func (ec *executionContext) unmarshalONullInt642databasesqlNullInt64(ctx context.Context, v interface{}) (sql.NullInt64, error) {
	res, err := internal.UnmarshalNullInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONullInt642databasesqlNullInt64(ctx context.Context, sel ast.SelectionSet, v sql.NullInt64) graphql.Marshaler {
	res := internal.MarshalNullInt64(v)
	return res
}

func (ec *executionContext) unmarshalONullInt642databasesqlNullInt64(ctx context.Context, v interface{}) (*sql.NullInt64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := internal.UnmarshalNullInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONullInt642databasesqlNullInt64(ctx context.Context, sel ast.SelectionSet, v *sql.NullInt64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := internal.MarshalNullInt64(*v)
	return res
}

func (ec *executionContext) unmarshalONullString2databasesqlNullString(ctx context.Context, v interface{}) (sql.NullString, error) {
	res, err := internal.UnmarshalNullString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONullString2databasesqlNullString(ctx context.Context, sel ast.SelectionSet, v sql.NullString) graphql.Marshaler {
	res := internal.MarshalNullString(v)
	return res
}

func (ec *executionContext) unmarshalONullString2databasesqlNullString(ctx context.Context, v interface{}) (*sql.NullString, error) {
	if v == nil {
		return nil, nil
	}
	res, err := internal.UnmarshalNullString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONullString2databasesqlNullString(ctx context.Context, sel ast.SelectionSet, v *sql.NullString) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := internal.MarshalNullString(*v)
	return res
}

func (ec *executionContext) unmarshalONullTime2databasesqlNullTime(ctx context.Context, v interface{}) (sql.NullTime, error) {
	res, err := internal.UnmarshalNullTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONullTime2databasesqlNullTime(ctx context.Context, sel ast.SelectionSet, v sql.NullTime) graphql.Marshaler {
	res := internal.MarshalNullTime(v)
	return res
}

func (ec *executionContext) unmarshalOPagination2githubcomketan10trainingbackendinternalPagination(ctx context.Context, v interface{}) (*internal.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPagination(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORegistrations2githubcomketan10trainingbackendxo_gentableRegistrations(ctx context.Context, sel ast.SelectionSet, v *table.Registrations) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Registrations(ctx, sel, v)
}

func (ec *executionContext) unmarshalORegistrationsFilter2githubcomketan10trainingbackendxo_gentableRegistrationsFilter(ctx context.Context, v interface{}) (*table.RegistrationsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRegistrationsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOStudents2githubcomketan10trainingbackendxo_gentableStudents(ctx context.Context, sel ast.SelectionSet, v *table.Students) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Students(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStudentsFilter2githubcomketan10trainingbackendxo_gentableStudentsFilter(ctx context.Context, v interface{}) (*table.StudentsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStudentsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTrainerTrainingMapping2githubcomketan10trainingbackendxo_gentableTrainerTrainingMapping(ctx context.Context, sel ast.SelectionSet, v *table.TrainerTrainingMapping) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TrainerTrainingMapping(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTrainerTrainingMappingFilter2githubcomketan10trainingbackendxo_gentableTrainerTrainingMappingFilter(ctx context.Context, v interface{}) (*table.TrainerTrainingMappingFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTrainerTrainingMappingFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTrainers2githubcomketan10trainingbackendxo_gentableTrainers(ctx context.Context, sel ast.SelectionSet, v *table.Trainers) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Trainers(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTrainersFilter2githubcomketan10trainingbackendxo_gentableTrainersFilter(ctx context.Context, v interface{}) (*table.TrainersFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTrainersFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTraining2githubcomketan10trainingbackendxo_gentableTraining(ctx context.Context, sel ast.SelectionSet, v *table.Training) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Training(ctx, sel, v)
}

func (ec *executionContext) marshalOTrainingEvent2githubcomketan10trainingbackendxo_gentableTrainingEvent(ctx context.Context, sel ast.SelectionSet, v *table.TrainingEvent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TrainingEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTrainingEventFilter2githubcomketan10trainingbackendxo_gentableTrainingEventFilter(ctx context.Context, v interface{}) (*table.TrainingEventFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTrainingEventFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTrainingEventStatus2githubcomketan10trainingbackendxo_genenumTrainingEventStatus(ctx context.Context, v interface{}) (*enum.TrainingEventStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(enum.TrainingEventStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTrainingEventStatus2githubcomketan10trainingbackendxo_genenumTrainingEventStatus(ctx context.Context, sel ast.SelectionSet, v *enum.TrainingEventStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTrainingFilter2githubcomketan10trainingbackendxo_gentableTrainingFilter(ctx context.Context, v interface{}) (*table.TrainingFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTrainingFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTrainingMode2githubcomketan10trainingbackendxo_genenumTrainingMode(ctx context.Context, v interface{}) (*enum.TrainingMode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(enum.TrainingMode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTrainingMode2githubcomketan10trainingbackendxo_genenumTrainingMode(ctx context.Context, sel ast.SelectionSet, v *enum.TrainingMode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTrainingType2githubcomketan10trainingbackendxo_genenumTrainingType(ctx context.Context, v interface{}) (*enum.TrainingType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(enum.TrainingType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTrainingType2githubcomketan10trainingbackendxo_genenumTrainingType(ctx context.Context, sel ast.SelectionSet, v *enum.TrainingType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOUser2githubcomketan10trainingbackendxo_gentableUser(ctx context.Context, sel ast.SelectionSet, v *table.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserFilter2githubcomketan10trainingbackendxo_gentableUserFilter(ctx context.Context, v interface{}) (*table.UserFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserRole2githubcomketan10trainingbackendxo_genenumUserRole(ctx context.Context, v interface{}) (*enum.UserRole, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(enum.UserRole)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserRole2githubcomketan10trainingbackendxo_genenumUserRole(ctx context.Context, sel ast.SelectionSet, v *enum.UserRole) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
