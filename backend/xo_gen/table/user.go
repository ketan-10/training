// Code generated by xo. DO NOT EDIT.

package table

import (
	"database/sql"

	sq "github.com/elgris/sqrl"
	"github.com/ketan-10/training/backend/internal"
	"github.com/ketan-10/training/backend/xo_gen/enum"
	"github.com/pkg/errors"
)

type User struct {
	ID       int            `json:"id" db:"id"`
	Username string         `json:"username" db:"username"`
	Email    string         `json:"email" db:"email"`
	Password sql.NullString `json:"password" db:"password"`
	Role     *enum.UserRole `json:"role" db:"role"`

	Active    bool         `json:"active" db:"active"`
	CreatedAt sql.NullTime `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
}

type UserFilter struct {
	ID        internal.FilterOnField
	Username  internal.FilterOnField
	Email     internal.FilterOnField
	Password  internal.FilterOnField
	Role      internal.FilterOnField
	Active    internal.FilterOnField
	CreatedAt internal.FilterOnField
	UpdatedAt internal.FilterOnField
	Wheres    []sq.Sqlizer
	Joins     []sq.Sqlizer
	LeftJoins []sq.Sqlizer
	GroupBys  []string
	Havings   []sq.Sqlizer
}

func (f *UserFilter) NewFilter() interface{} {
	if f == nil {
		return &UserFilter{}
	}
	return f
}

func (f *UserFilter) TableName() string {
	return "`user`"
}

func (f *UserFilter) ModuleName() string {
	return "user"
}

func (f *UserFilter) IsNil() bool {
	return f == nil
}
func (f *UserFilter) AddID(filterType internal.FilterType, v interface{}) {
	f.ID = append(f.ID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *UserFilter) AddUsername(filterType internal.FilterType, v interface{}) {
	f.Username = append(f.Username, map[internal.FilterType]interface{}{filterType: v})
}
func (f *UserFilter) AddEmail(filterType internal.FilterType, v interface{}) {
	f.Email = append(f.Email, map[internal.FilterType]interface{}{filterType: v})
}
func (f *UserFilter) AddPassword(filterType internal.FilterType, v interface{}) {
	f.Password = append(f.Password, map[internal.FilterType]interface{}{filterType: v})
}
func (f *UserFilter) AddRole(filterType internal.FilterType, v interface{}) {
	f.Role = append(f.Role, map[internal.FilterType]interface{}{filterType: v})
}
func (f *UserFilter) AddActive(filterType internal.FilterType, v interface{}) {
	f.Active = append(f.Active, map[internal.FilterType]interface{}{filterType: v})
}
func (f *UserFilter) AddCreatedAt(filterType internal.FilterType, v interface{}) {
	f.CreatedAt = append(f.CreatedAt, map[internal.FilterType]interface{}{filterType: v})
}
func (f *UserFilter) AddUpdatedAt(filterType internal.FilterType, v interface{}) {
	f.UpdatedAt = append(f.UpdatedAt, map[internal.FilterType]interface{}{filterType: v})
}

func (f *UserFilter) Where(v sq.Sqlizer) *UserFilter {
	f.Wheres = append(f.Wheres, v)
	return f
}

func (f *UserFilter) Join(j sq.Sqlizer) *UserFilter {
	f.Joins = append(f.Joins, j)
	return f
}

func (f *UserFilter) LeftJoin(j sq.Sqlizer) *UserFilter {
	f.LeftJoins = append(f.LeftJoins, j)
	return f
}

func (f *UserFilter) GroupBy(gb string) *UserFilter {
	f.GroupBys = append(f.GroupBys, gb)
	return f
}

func (f *UserFilter) Having(h sq.Sqlizer) *UserFilter {
	f.Havings = append(f.Havings, h)
	return f
}

type UserCreate struct {
	Username string         `json:"username" db:"username"`
	Email    string         `json:"email" db:"email"`
	Password sql.NullString `json:"password" db:"password"`
	Role     *enum.UserRole `json:"role" db:"role"`
}

// TODO: We have to exclude AutoGenerated fields
// For now I am keeping it in, as not sure how it affects
type UserUpdate struct {
	Username *string         // username
	Email    *string         // email
	Password *sql.NullString // password
	Role     *enum.UserRole  // role
	Active   *bool           // active
}

// helper functions
func (u *UserUpdate) ToUserCreate() (res UserCreate, err error) {
	if u.Username != nil {
		res.Username = *u.Username
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.Email != nil {
		res.Email = *u.Email
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.Password != nil {
		res.Password = *u.Password
	}
	if u.Role != nil {
		res.Role = u.Role
	}
	return res, nil
}

type ListUser struct {
	TotalCount int
	Data       []User
}

func (l *ListUser) GetAllID() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.ID)
	}
	return res
}
func (l *ListUser) GetAllUsername() []string {
	var res []string
	for _, item := range l.Data {
		res = append(res, item.Username)
	}
	return res
}
func (l *ListUser) GetAllEmail() []string {
	var res []string
	for _, item := range l.Data {
		res = append(res, item.Email)
	}
	return res
}
func (l *ListUser) GetAllPassword() []sql.NullString {
	var res []sql.NullString
	for _, item := range l.Data {
		res = append(res, item.Password)
	}
	return res
}
func (l *ListUser) GetAllRole() []*enum.UserRole {
	var res []*enum.UserRole
	for _, item := range l.Data {
		res = append(res, item.Role)
	}
	return res
}
func (l *ListUser) GetAllActive() []bool {
	var res []bool
	for _, item := range l.Data {
		res = append(res, item.Active)
	}
	return res
}
func (l *ListUser) GetAllCreatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.CreatedAt)
	}
	return res
}
func (l *ListUser) GetAllUpdatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.UpdatedAt)
	}
	return res
}

func (l *ListUser) Filter(f func(item User) bool) (res ListUser) {
	for _, item := range l.Data {
		if f(item) {
			res.Data = append(res.Data, item)
		}
	}
	res.TotalCount = len(res.Data)
	return res
}

func (l *ListUser) Find(f func(item User) bool) (res User, found bool) {
	for _, item := range l.Data {
		if f(item) {
			return item, true
		}
	}
	return User{}, false
}
func (l *ListUser) MapByID() (m map[int]User) {
	m = make(map[int]User, len(l.Data))
	for _, item := range l.Data {
		m[item.ID] = item
	}
	return m
}

func (l *ListUser) MapByEmail() (m map[string]ListUser) {
	m = make(map[string]ListUser)
	for _, item := range l.Data {
		list := m[item.Email]
		list.Data = append(list.Data, item)

		m[item.Email] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}

func (l *ListUser) MapByUsername() (m map[string]ListUser) {
	m = make(map[string]ListUser)
	for _, item := range l.Data {
		list := m[item.Username]
		list.Data = append(list.Data, item)

		m[item.Username] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}
