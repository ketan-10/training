// Code generated by xo. DO NOT EDIT.

package table

import (
	"database/sql"

	sq "github.com/elgris/sqrl"
	"github.com/ketan-10/training/backend/internal"
	"github.com/ketan-10/training/backend/xo_gen/enum"
	"github.com/pkg/errors"
)

type Training struct {
	ID           int                `json:"id" db:"id"`
	TrainingName string             `json:"training_name" db:"training_name"`
	Mode         *enum.TrainingMode `json:"mode" db:"mode"`

	Type *enum.TrainingType `json:"type" db:"type"`

	RequestedBy            sql.NullInt64  `json:"requested_by" db:"requested_by"`
	IsRegistrationRequired sql.NullBool   `json:"is_registration_required" db:"is_registration_required"`
	Tags                   sql.NullString `json:"tags" db:"tags"`
	Active                 bool           `json:"active" db:"active"`
	CreatedAt              sql.NullTime   `json:"created_at" db:"created_at"`
	UpdatedAt              sql.NullTime   `json:"updated_at" db:"updated_at"`
	CreatedBy              sql.NullInt64  `json:"created_by" db:"created_by"`
}

type TrainingFilter struct {
	ID                     internal.FilterOnField
	TrainingName           internal.FilterOnField
	Mode                   internal.FilterOnField
	Type                   internal.FilterOnField
	RequestedBy            internal.FilterOnField
	IsRegistrationRequired internal.FilterOnField
	Tags                   internal.FilterOnField
	Active                 internal.FilterOnField
	CreatedAt              internal.FilterOnField
	UpdatedAt              internal.FilterOnField
	CreatedBy              internal.FilterOnField
	Wheres                 []sq.Sqlizer
	Joins                  []sq.Sqlizer
	LeftJoins              []sq.Sqlizer
	GroupBys               []string
	Havings                []sq.Sqlizer
}

func (f *TrainingFilter) NewFilter() interface{} {
	if f == nil {
		return &TrainingFilter{}
	}
	return f
}

func (f *TrainingFilter) TableName() string {
	return "`training`"
}

func (f *TrainingFilter) ModuleName() string {
	return "training"
}

func (f *TrainingFilter) IsNil() bool {
	return f == nil
}
func (f *TrainingFilter) AddID(filterType internal.FilterType, v interface{}) {
	f.ID = append(f.ID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainingFilter) AddTrainingName(filterType internal.FilterType, v interface{}) {
	f.TrainingName = append(f.TrainingName, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainingFilter) AddMode(filterType internal.FilterType, v interface{}) {
	f.Mode = append(f.Mode, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainingFilter) AddType(filterType internal.FilterType, v interface{}) {
	f.Type = append(f.Type, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainingFilter) AddRequestedBy(filterType internal.FilterType, v interface{}) {
	f.RequestedBy = append(f.RequestedBy, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainingFilter) AddIsRegistrationRequired(filterType internal.FilterType, v interface{}) {
	f.IsRegistrationRequired = append(f.IsRegistrationRequired, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainingFilter) AddTags(filterType internal.FilterType, v interface{}) {
	f.Tags = append(f.Tags, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainingFilter) AddActive(filterType internal.FilterType, v interface{}) {
	f.Active = append(f.Active, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainingFilter) AddCreatedAt(filterType internal.FilterType, v interface{}) {
	f.CreatedAt = append(f.CreatedAt, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainingFilter) AddUpdatedAt(filterType internal.FilterType, v interface{}) {
	f.UpdatedAt = append(f.UpdatedAt, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainingFilter) AddCreatedBy(filterType internal.FilterType, v interface{}) {
	f.CreatedBy = append(f.CreatedBy, map[internal.FilterType]interface{}{filterType: v})
}

func (f *TrainingFilter) Where(v sq.Sqlizer) *TrainingFilter {
	f.Wheres = append(f.Wheres, v)
	return f
}

func (f *TrainingFilter) Join(j sq.Sqlizer) *TrainingFilter {
	f.Joins = append(f.Joins, j)
	return f
}

func (f *TrainingFilter) LeftJoin(j sq.Sqlizer) *TrainingFilter {
	f.LeftJoins = append(f.LeftJoins, j)
	return f
}

func (f *TrainingFilter) GroupBy(gb string) *TrainingFilter {
	f.GroupBys = append(f.GroupBys, gb)
	return f
}

func (f *TrainingFilter) Having(h sq.Sqlizer) *TrainingFilter {
	f.Havings = append(f.Havings, h)
	return f
}

type TrainingCreate struct {
	TrainingName           string             `json:"training_name" db:"training_name"`
	Mode                   *enum.TrainingMode `json:"mode" db:"mode"`
	Type                   *enum.TrainingType `json:"type" db:"type"`
	RequestedBy            sql.NullInt64      `json:"requested_by" db:"requested_by"`
	IsRegistrationRequired sql.NullBool       `json:"is_registration_required" db:"is_registration_required"`
	Tags                   sql.NullString     `json:"tags" db:"tags"`
	CreatedBy              sql.NullInt64      `json:"created_by" db:"created_by"`
}

// TODO: We have to exclude AutoGenerated fields
// For now I am keeping it in, as not sure how it affects
type TrainingUpdate struct {
	TrainingName           *string            // training_name
	Mode                   *enum.TrainingMode // mode
	Type                   *enum.TrainingType // type
	RequestedBy            *sql.NullInt64     // requested_by
	IsRegistrationRequired *sql.NullBool      // is_registration_required
	Tags                   *sql.NullString    // tags
	Active                 *bool              // active
	CreatedBy              *sql.NullInt64     // created_by
}

// helper functions
func (u *TrainingUpdate) ToTrainingCreate() (res TrainingCreate, err error) {
	if u.TrainingName != nil {
		res.TrainingName = *u.TrainingName
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.Mode != nil {
		res.Mode = u.Mode
	}
	if u.Type != nil {
		res.Type = u.Type
	}
	if u.RequestedBy != nil {
		res.RequestedBy = *u.RequestedBy
	}
	if u.IsRegistrationRequired != nil {
		res.IsRegistrationRequired = *u.IsRegistrationRequired
	}
	if u.Tags != nil {
		res.Tags = *u.Tags
	}
	if u.CreatedBy != nil {
		res.CreatedBy = *u.CreatedBy
	}
	return res, nil
}

type ListTraining struct {
	TotalCount int
	Data       []Training
}

func (l *ListTraining) GetAllID() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.ID)
	}
	return res
}
func (l *ListTraining) GetAllTrainingName() []string {
	var res []string
	for _, item := range l.Data {
		res = append(res, item.TrainingName)
	}
	return res
}
func (l *ListTraining) GetAllMode() []*enum.TrainingMode {
	var res []*enum.TrainingMode
	for _, item := range l.Data {
		res = append(res, item.Mode)
	}
	return res
}
func (l *ListTraining) GetAllType() []*enum.TrainingType {
	var res []*enum.TrainingType
	for _, item := range l.Data {
		res = append(res, item.Type)
	}
	return res
}
func (l *ListTraining) GetAllRequestedBy() []sql.NullInt64 {
	var res []sql.NullInt64
	for _, item := range l.Data {
		res = append(res, item.RequestedBy)
	}
	return res
}
func (l *ListTraining) GetAllIsRegistrationRequired() []sql.NullBool {
	var res []sql.NullBool
	for _, item := range l.Data {
		res = append(res, item.IsRegistrationRequired)
	}
	return res
}
func (l *ListTraining) GetAllTags() []sql.NullString {
	var res []sql.NullString
	for _, item := range l.Data {
		res = append(res, item.Tags)
	}
	return res
}
func (l *ListTraining) GetAllActive() []bool {
	var res []bool
	for _, item := range l.Data {
		res = append(res, item.Active)
	}
	return res
}
func (l *ListTraining) GetAllCreatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.CreatedAt)
	}
	return res
}
func (l *ListTraining) GetAllUpdatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.UpdatedAt)
	}
	return res
}
func (l *ListTraining) GetAllCreatedBy() []sql.NullInt64 {
	var res []sql.NullInt64
	for _, item := range l.Data {
		res = append(res, item.CreatedBy)
	}
	return res
}

func (l *ListTraining) Filter(f func(item Training) bool) (res ListTraining) {
	for _, item := range l.Data {
		if f(item) {
			res.Data = append(res.Data, item)
		}
	}
	res.TotalCount = len(res.Data)
	return res
}

func (l *ListTraining) Find(f func(item Training) bool) (res Training, found bool) {
	for _, item := range l.Data {
		if f(item) {
			return item, true
		}
	}
	return Training{}, false
}

func (l *ListTraining) MapByTrainingName() (m map[string]ListTraining) {
	m = make(map[string]ListTraining)
	for _, item := range l.Data {
		list := m[item.TrainingName]
		list.Data = append(list.Data, item)

		m[item.TrainingName] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}

func (l *ListTraining) MapByCreatedBy() (m map[sql.NullInt64]ListTraining) {
	m = make(map[sql.NullInt64]ListTraining)
	for _, item := range l.Data {
		list := m[item.CreatedBy]
		list.Data = append(list.Data, item)

		m[item.CreatedBy] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}

func (l *ListTraining) MapByID() (m map[int]Training) {
	m = make(map[int]Training, len(l.Data))
	for _, item := range l.Data {
		m[item.ID] = item
	}
	return m
}

func (l *ListTraining) MapByRequestedBy() (m map[sql.NullInt64]ListTraining) {
	m = make(map[sql.NullInt64]ListTraining)
	for _, item := range l.Data {
		list := m[item.RequestedBy]
		list.Data = append(list.Data, item)

		m[item.RequestedBy] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}
