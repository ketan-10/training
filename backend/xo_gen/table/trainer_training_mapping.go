// Code generated by xo. DO NOT EDIT.

package table

import (
	"database/sql"

	sq "github.com/elgris/sqrl"
	"github.com/ketan-10/classroom/backend/internal"
	"github.com/pkg/errors"
)

type TrainerTrainingMapping struct {
	ID                 int          `json:"id" db:"id"`
	FkTrainingEvent    int          `json:"fk_training_event" db:"fk_training_event"`
	FkExternalResource int          `json:"fk_external_resource" db:"fk_external_resource"`
	FkInternalResource int          `json:"fk_internal_resource" db:"fk_internal_resource"`
	Active             bool         `json:"active" db:"active"`
	CreatedAt          sql.NullTime `json:"created_at" db:"created_at"`
	UpdatedAt          sql.NullTime `json:"updated_at" db:"updated_at"`
}

type TrainerTrainingMappingFilter struct {
	ID                 internal.FilterOnField
	FkTrainingEvent    internal.FilterOnField
	FkExternalResource internal.FilterOnField
	FkInternalResource internal.FilterOnField
	Active             internal.FilterOnField
	CreatedAt          internal.FilterOnField
	UpdatedAt          internal.FilterOnField
	Wheres             []sq.Sqlizer
	Joins              []sq.Sqlizer
	LeftJoins          []sq.Sqlizer
	GroupBys           []string
	Havings            []sq.Sqlizer
}

func (f *TrainerTrainingMappingFilter) NewFilter() interface{} {
	if f == nil {
		return &TrainerTrainingMappingFilter{}
	}
	return f
}

func (f *TrainerTrainingMappingFilter) TableName() string {
	return "`trainer_training_mapping`"
}

func (f *TrainerTrainingMappingFilter) ModuleName() string {
	return "trainer_training_mapping"
}

func (f *TrainerTrainingMappingFilter) IsNil() bool {
	return f == nil
}
func (f *TrainerTrainingMappingFilter) AddID(filterType internal.FilterType, v interface{}) {
	f.ID = append(f.ID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainerTrainingMappingFilter) AddFkTrainingEvent(filterType internal.FilterType, v interface{}) {
	f.FkTrainingEvent = append(f.FkTrainingEvent, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainerTrainingMappingFilter) AddFkExternalResource(filterType internal.FilterType, v interface{}) {
	f.FkExternalResource = append(f.FkExternalResource, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainerTrainingMappingFilter) AddFkInternalResource(filterType internal.FilterType, v interface{}) {
	f.FkInternalResource = append(f.FkInternalResource, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainerTrainingMappingFilter) AddActive(filterType internal.FilterType, v interface{}) {
	f.Active = append(f.Active, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainerTrainingMappingFilter) AddCreatedAt(filterType internal.FilterType, v interface{}) {
	f.CreatedAt = append(f.CreatedAt, map[internal.FilterType]interface{}{filterType: v})
}
func (f *TrainerTrainingMappingFilter) AddUpdatedAt(filterType internal.FilterType, v interface{}) {
	f.UpdatedAt = append(f.UpdatedAt, map[internal.FilterType]interface{}{filterType: v})
}

func (f *TrainerTrainingMappingFilter) Where(v sq.Sqlizer) *TrainerTrainingMappingFilter {
	f.Wheres = append(f.Wheres, v)
	return f
}

func (f *TrainerTrainingMappingFilter) Join(j sq.Sqlizer) *TrainerTrainingMappingFilter {
	f.Joins = append(f.Joins, j)
	return f
}

func (f *TrainerTrainingMappingFilter) LeftJoin(j sq.Sqlizer) *TrainerTrainingMappingFilter {
	f.LeftJoins = append(f.LeftJoins, j)
	return f
}

func (f *TrainerTrainingMappingFilter) GroupBy(gb string) *TrainerTrainingMappingFilter {
	f.GroupBys = append(f.GroupBys, gb)
	return f
}

func (f *TrainerTrainingMappingFilter) Having(h sq.Sqlizer) *TrainerTrainingMappingFilter {
	f.Havings = append(f.Havings, h)
	return f
}

type TrainerTrainingMappingCreate struct {
	FkTrainingEvent    int `json:"fk_training_event" db:"fk_training_event"`
	FkExternalResource int `json:"fk_external_resource" db:"fk_external_resource"`
	FkInternalResource int `json:"fk_internal_resource" db:"fk_internal_resource"`
}

// TODO: We have to exclude AutoGenerated fields
// For now I am keeping it in, as not sure how it affects
type TrainerTrainingMappingUpdate struct {
	FkTrainingEvent    *int  // fk_training_event
	FkExternalResource *int  // fk_external_resource
	FkInternalResource *int  // fk_internal_resource
	Active             *bool // active
}

// helper functions
func (u *TrainerTrainingMappingUpdate) ToTrainerTrainingMappingCreate() (res TrainerTrainingMappingCreate, err error) {
	if u.FkTrainingEvent != nil {
		res.FkTrainingEvent = *u.FkTrainingEvent
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.FkExternalResource != nil {
		res.FkExternalResource = *u.FkExternalResource
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.FkInternalResource != nil {
		res.FkInternalResource = *u.FkInternalResource
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	return res, nil
}

type ListTrainerTrainingMapping struct {
	TotalCount int
	Data       []TrainerTrainingMapping
}

func (l *ListTrainerTrainingMapping) GetAllID() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.ID)
	}
	return res
}
func (l *ListTrainerTrainingMapping) GetAllFkTrainingEvent() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.FkTrainingEvent)
	}
	return res
}
func (l *ListTrainerTrainingMapping) GetAllFkExternalResource() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.FkExternalResource)
	}
	return res
}
func (l *ListTrainerTrainingMapping) GetAllFkInternalResource() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.FkInternalResource)
	}
	return res
}
func (l *ListTrainerTrainingMapping) GetAllActive() []bool {
	var res []bool
	for _, item := range l.Data {
		res = append(res, item.Active)
	}
	return res
}
func (l *ListTrainerTrainingMapping) GetAllCreatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.CreatedAt)
	}
	return res
}
func (l *ListTrainerTrainingMapping) GetAllUpdatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.UpdatedAt)
	}
	return res
}

func (l *ListTrainerTrainingMapping) Filter(f func(item TrainerTrainingMapping) bool) (res ListTrainerTrainingMapping) {
	for _, item := range l.Data {
		if f(item) {
			res.Data = append(res.Data, item)
		}
	}
	res.TotalCount = len(res.Data)
	return res
}

func (l *ListTrainerTrainingMapping) Find(f func(item TrainerTrainingMapping) bool) (res TrainerTrainingMapping, found bool) {
	for _, item := range l.Data {
		if f(item) {
			return item, true
		}
	}
	return TrainerTrainingMapping{}, false
}

func (l *ListTrainerTrainingMapping) MapByFkExternalResource() (m map[int]ListTrainerTrainingMapping) {
	m = make(map[int]ListTrainerTrainingMapping)
	for _, item := range l.Data {
		list := m[item.FkExternalResource]
		list.Data = append(list.Data, item)

		m[item.FkExternalResource] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}

func (l *ListTrainerTrainingMapping) MapByFkInternalResource() (m map[int]ListTrainerTrainingMapping) {
	m = make(map[int]ListTrainerTrainingMapping)
	for _, item := range l.Data {
		list := m[item.FkInternalResource]
		list.Data = append(list.Data, item)

		m[item.FkInternalResource] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}

func (l *ListTrainerTrainingMapping) MapByFkTrainingEvent() (m map[int]ListTrainerTrainingMapping) {
	m = make(map[int]ListTrainerTrainingMapping)
	for _, item := range l.Data {
		list := m[item.FkTrainingEvent]
		list.Data = append(list.Data, item)

		m[item.FkTrainingEvent] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}

func (l *ListTrainerTrainingMapping) MapByID() (m map[int]TrainerTrainingMapping) {
	m = make(map[int]TrainerTrainingMapping, len(l.Data))
	for _, item := range l.Data {
		m[item.ID] = item
	}
	return m
}
