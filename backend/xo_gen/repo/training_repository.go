// Code generated by xo. DO NOT EDIT.

package repo

import (
	"context"
	"database/sql"

	sq "github.com/elgris/sqrl"
	"github.com/google/wire"
	"github.com/ketan-10/classroom/backend/internal"
	"github.com/ketan-10/classroom/backend/xo_gen/table"
)

type ITrainingRepository interface {
	ITrainingRepositoryQueryBuilder

	InsertTraining(ctx context.Context, t table.TrainingCreate) (*table.Training, error)
	InsertTrainingWithSuffix(ctx context.Context, t table.TrainingCreate, suffix sq.Sqlizer) (*table.Training, error)
	InsertTrainingIDResult(ctx context.Context, t table.TrainingCreate, suffix sq.Sqlizer) (int64, error)

	UpdateTrainingByFields(ctx context.Context, id int, t table.TrainingUpdate) (*table.Training, error)
	UpdateTraining(ctx context.Context, t table.Training) (*table.Training, error)

	DeleteTraining(ctx context.Context, t table.Training) error
	DeleteTrainingByID(ctx context.Context, id int) (bool, error)

	FindAllTraining(ctx context.Context, t *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error)
	FindAllTrainingWithSuffix(ctx context.Context, t *table.TrainingFilter, pagination *internal.Pagination, suffixes ...sq.Sqlizer) (*table.ListTraining, error)

	TrainingByTrainingName(ctx context.Context, trainingName string, filter *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error)

	TrainingByTrainingNameWithSuffix(ctx context.Context, trainingName string, filter *table.TrainingFilter, pagination *internal.Pagination, suffixes ...sq.Sqlizer) (*table.ListTraining, error)

	TrainingByCreatedBy(ctx context.Context, createdBy sql.NullInt64, filter *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error)

	TrainingByCreatedByWithSuffix(ctx context.Context, createdBy sql.NullInt64, filter *table.TrainingFilter, pagination *internal.Pagination, suffixes ...sq.Sqlizer) (*table.ListTraining, error)
	TrainingByID(ctx context.Context, id int, filter *table.TrainingFilter) (table.Training, error)

	TrainingByIDWithSuffix(ctx context.Context, id int, filter *table.TrainingFilter, suffixes ...sq.Sqlizer) (table.Training, error)

	TrainingByRequestedBy(ctx context.Context, requestedBy sql.NullInt64, filter *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error)

	TrainingByRequestedByWithSuffix(ctx context.Context, requestedBy sql.NullInt64, filter *table.TrainingFilter, pagination *internal.Pagination, suffixes ...sq.Sqlizer) (*table.ListTraining, error)
}

type ITrainingRepositoryQueryBuilder interface {
	FindAllTrainingBaseQuery(ctx context.Context, filter *table.TrainingFilter, fields string, suffix ...sq.Sqlizer) (*sq.SelectBuilder, error)
	AddPagination(ctx context.Context, qb *sq.SelectBuilder, pagination *internal.Pagination) (*sq.SelectBuilder, error)
}

type TrainingRepository struct {
	DB           internal.IDb
	QueryBuilder ITrainingRepositoryQueryBuilder
}

type TrainingRepositoryQueryBuilder struct {
}

var NewTrainingRepository = wire.NewSet(
	wire.Struct(new(TrainingRepository), "*"),
	wire.Struct(new(TrainingRepositoryQueryBuilder), "*"),
	wire.Bind(new(ITrainingRepository), new(*TrainingRepository)),
	wire.Bind(new(ITrainingRepositoryQueryBuilder), new(*TrainingRepositoryQueryBuilder)),
)

func (tr *TrainingRepository) InsertTraining(ctx context.Context, t table.TrainingCreate) (*table.Training, error) {
	return tr.InsertTrainingWithSuffix(ctx, t, nil)
}

func (tr *TrainingRepository) InsertTrainingWithSuffix(ctx context.Context, t table.TrainingCreate, suffix sq.Sqlizer) (*table.Training, error) {
	var err error

	id, err := tr.InsertTrainingIDResult(ctx, t, suffix)
	if err != nil {
		return nil, err
	}
	newt := table.Training{}
	qb := sq.Select("*").From(`training`)

	qb.Where(sq.Eq{"`id`": id})
	err = tr.DB.Get(ctx, &newt, qb)

	if err != nil {
		return nil, err
	}
	return &newt, nil
}

func (tr *TrainingRepository) InsertTrainingIDResult(ctx context.Context, t table.TrainingCreate, suffix sq.Sqlizer) (int64, error) {
	var err error

	qb := sq.Insert("`training`").Columns(
		"`training_name`",
		"`mode`",
		"`type`",
		"`requested_by`",
		"`is_registration_required`",
		"`tags`",
		"`created_by`",
	).Values(
		t.TrainingName,
		t.Mode,
		t.Type,
		t.RequestedBy,
		t.IsRegistrationRequired,
		t.Tags,
		t.CreatedBy,
	)
	if suffix != nil {
		suffixQuery, suffixArgs, suffixErr := suffix.ToSql()
		if suffixErr != nil {
			return 0, suffixErr
		}
		qb.Suffix(suffixQuery, suffixArgs...)
	}

	// run query
	res, err := tr.DB.Exec(ctx, qb)
	if err != nil {
		return 0, err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return 0, err
	}

	return id, nil
}

func (tr *TrainingRepository) UpdateTrainingByFields(ctx context.Context, id int, t table.TrainingUpdate) (*table.Training, error) {
	var err error

	updateMap := map[string]interface{}{}
	if t.TrainingName != nil {
		updateMap["`training_name`"] = *t.TrainingName
	}
	if t.Mode != nil {
		updateMap["`mode`"] = *t.Mode
	}
	if t.Type != nil {
		updateMap["`type`"] = *t.Type
	}
	if t.RequestedBy != nil {
		updateMap["`requested_by`"] = *t.RequestedBy
	}
	if t.IsRegistrationRequired != nil {
		updateMap["`is_registration_required`"] = *t.IsRegistrationRequired
	}
	if t.Tags != nil {
		updateMap["`tags`"] = *t.Tags
	}
	if t.Active != nil {
		updateMap["`active`"] = *t.Active
	}
	if t.CreatedBy != nil {
		updateMap["`created_by`"] = *t.CreatedBy
	}

	qb := sq.Update(`training`).SetMap(updateMap).Where(sq.Eq{"`id`": id})

	_, err = tr.DB.Exec(ctx, qb)
	if err != nil {
		return nil, err
	}

	selectQb := sq.Select("*").From("`training`")

	selectQb = selectQb.Where(sq.Eq{"`id`": id})

	result := table.Training{}
	err = tr.DB.Get(ctx, &result, selectQb)
	if err != nil {
		return nil, err
	}

	return &result, nil

}

func (tr *TrainingRepository) UpdateTraining(ctx context.Context, t table.Training) (*table.Training, error) {
	var err error

	// sql query
	qb := sq.Update("`training`").SetMap(map[string]interface{}{
		"`training_name`":            t.TrainingName,
		"`mode`":                     t.Mode,
		"`type`":                     t.Type,
		"`requested_by`":             t.RequestedBy,
		"`is_registration_required`": t.IsRegistrationRequired,
		"`tags`":                     t.Tags,
		"`active`":                   t.Active,
		"`created_by`":               t.CreatedBy,
	}).Where(sq.Eq{"`id`": t.ID})

	// run query
	_, err = tr.DB.Exec(ctx, qb)
	if err != nil {
		return nil, err
	}

	selectQb := sq.Select("*").From("`training`")
	selectQb = selectQb.Where(sq.Eq{"`id`": t.ID})

	result := table.Training{}
	err = tr.DB.Get(ctx, &result, selectQb)
	if err != nil {
		return nil, err
	}

	return &result, nil
}

func (tr *TrainingRepository) DeleteTraining(ctx context.Context, t table.Training) error {
	_, err := tr.DeleteTrainingByID(ctx, t.ID)
	return err
}

func (tr *TrainingRepository) DeleteTrainingByID(ctx context.Context, id int) (bool, error) {
	var err error

	qb := sq.Update("`training`").Set("active", false)

	qb = qb.Where(sq.Eq{"`id`": id})

	_, err = tr.DB.Exec(ctx, qb)
	if err != nil {
		return false, err
	}
	return true, nil
}

func (tr *TrainingRepository) FindAllTrainingBaseQuery(ctx context.Context, filter *table.TrainingFilter, fields string, suffixes ...sq.Sqlizer) (*sq.SelectBuilder, error) {
	return tr.QueryBuilder.FindAllTrainingBaseQuery(ctx, filter, fields, suffixes...)
}

func (tr *TrainingRepositoryQueryBuilder) FindAllTrainingBaseQuery(ctx context.Context, filter *table.TrainingFilter, fields string, suffixes ...sq.Sqlizer) (*sq.SelectBuilder, error) {
	var err error
	qb := sq.Select(fields).From("`training`")
	if filter != nil {
		if qb, err = internal.AddFilter(qb, "`training`.`id`", filter.ID); err != nil {
			return qb, err
		}
		if qb, err = internal.AddFilter(qb, "`training`.`training_name`", filter.TrainingName); err != nil {
			return qb, err
		}
		if qb, err = internal.AddFilter(qb, "`training`.`mode`", filter.Mode); err != nil {
			return qb, err
		}
		if qb, err = internal.AddFilter(qb, "`training`.`type`", filter.Type); err != nil {
			return qb, err
		}
		if qb, err = internal.AddFilter(qb, "`training`.`requested_by`", filter.RequestedBy); err != nil {
			return qb, err
		}
		if qb, err = internal.AddFilter(qb, "`training`.`is_registration_required`", filter.IsRegistrationRequired); err != nil {
			return qb, err
		}
		if qb, err = internal.AddFilter(qb, "`training`.`tags`", filter.Tags); err != nil {
			return qb, err
		}
		if filter.Active == nil {
			if qb, err = internal.AddFilter(qb, "`training`.`active`", internal.FilterOnField{{internal.Eq: true}}); err != nil {
				return qb, err
			}
		} else {
			if qb, err = internal.AddFilter(qb, "`training`.`active`", filter.Active); err != nil {
				return qb, err
			}
		}
		if qb, err = internal.AddFilter(qb, "`training`.`created_at`", filter.CreatedAt); err != nil {
			return qb, err
		}
		if qb, err = internal.AddFilter(qb, "`training`.`updated_at`", filter.UpdatedAt); err != nil {
			return qb, err
		}
		if qb, err = internal.AddFilter(qb, "`training`.`created_by`", filter.CreatedBy); err != nil {
			return qb, err
		}
		qb, err = internal.AddAdditionalFilter(qb, filter.Wheres, filter.Joins, filter.LeftJoins, filter.GroupBys, filter.Havings)
		if err != nil {
			return qb, err
		}
	} else {
		if qb, err = internal.AddFilter(qb, "`training`.`active`", internal.FilterOnField{{internal.Eq: true}}); err != nil {
			return qb, err
		}
	}

	for _, suffix := range suffixes {
		query, args, err := suffix.ToSql()
		if err != nil {
			return qb, err
		}
		qb.Suffix(query, args...)
	}
	return qb, nil
}

func (tr *TrainingRepository) AddPagination(ctx context.Context, qb *sq.SelectBuilder, pagination *internal.Pagination) (*sq.SelectBuilder, error) {
	return tr.QueryBuilder.AddPagination(ctx, qb, pagination)
}

func (t *TrainingRepositoryQueryBuilder) AddPagination(ctx context.Context, qb *sq.SelectBuilder, pagination *internal.Pagination) (*sq.SelectBuilder, error) {
	fields := []string{
		"id",
		"training_name",
		"mode",
		"type",
		"requested_by",
		"is_registration_required",
		"tags",
		"active",
		"created_at",
		"updated_at",
		"created_by",
	}
	return internal.AddPagination(qb, pagination, "training", fields)
}

func (tr *TrainingRepository) FindAllTraining(ctx context.Context, filter *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error) {
	return tr.FindAllTrainingWithSuffix(ctx, filter, pagination)
}

func (tr *TrainingRepository) FindAllTrainingWithSuffix(ctx context.Context, filter *table.TrainingFilter, pagination *internal.Pagination, suffixes ...sq.Sqlizer) (*table.ListTraining, error) {
	var list table.ListTraining
	qb, err := tr.FindAllTrainingBaseQuery(ctx, filter, "`training`.*", suffixes...)
	if err != nil {
		return &list, err
	}
	qb, err = tr.AddPagination(ctx, qb, pagination)
	if err != nil {
		return &list, err
	}

	err = tr.DB.Select(ctx, &list.Data, qb)

	if err != nil {
		return &list, err
	}

	if pagination == nil || pagination.PerPage == nil || pagination.Page == nil {
		list.TotalCount = len(list.Data)
		return &list, nil
	}

	var listMeta internal.ListMetadata
	if qb, err = tr.FindAllTrainingBaseQuery(ctx, filter, "COUNT(1) AS count"); err != nil {
		return &table.ListTraining{}, err
	}
	if filter != nil && len(filter.GroupBys) > 0 {
		qb = sq.Select("COUNT(1) AS count").FromSelect(qb, "a")
	}
	err = tr.DB.Get(ctx, &listMeta, qb)

	list.TotalCount = listMeta.Count

	return &list, err
}

func (tr *TrainingRepository) TrainingByTrainingName(ctx context.Context, trainingName string, filter *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error) {
	return tr.TrainingByTrainingNameWithSuffix(ctx, trainingName, filter, pagination)
}

func (tr *TrainingRepository) TrainingByTrainingNameWithSuffix(ctx context.Context, trainingName string, filter *table.TrainingFilter, pagination *internal.Pagination, suffixes ...sq.Sqlizer) (*table.ListTraining, error) {

	var list table.ListTraining
	// sql query
	qb, err := tr.FindAllTrainingBaseQuery(ctx, filter, "`training`.*", suffixes...)
	if err != nil {
		return &list, err
	}
	qb = qb.Where(sq.Eq{"`training`.`training_name`": trainingName})

	if qb, err = tr.AddPagination(ctx, qb, pagination); err != nil {
		return &list, err
	}

	// run query
	if err = tr.DB.Select(ctx, &list.Data, qb); err != nil {
		return &list, err
	}

	if pagination == nil || pagination.PerPage == nil || pagination.Page == nil {
		list.TotalCount = len(list.Data)
		return &list, nil
	}

	var listMeta internal.ListMetadata
	if qb, err = tr.FindAllTrainingBaseQuery(ctx, filter, "COUNT(1) AS count"); err != nil {
		return &list, err
	}
	if filter != nil && len(filter.GroupBys) > 0 {
		qb = sq.Select("COUNT(1) AS count").FromSelect(qb, "a")
	}
	qb = qb.Where(sq.Eq{"`training`.`training_name`": trainingName})
	if err = tr.DB.Get(ctx, &listMeta, qb); err != nil {
		return &list, err
	}

	list.TotalCount = listMeta.Count

	return &list, nil

}

func (tr *TrainingRepository) TrainingByCreatedBy(ctx context.Context, createdBy sql.NullInt64, filter *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error) {
	return tr.TrainingByCreatedByWithSuffix(ctx, createdBy, filter, pagination)
}

func (tr *TrainingRepository) TrainingByCreatedByWithSuffix(ctx context.Context, createdBy sql.NullInt64, filter *table.TrainingFilter, pagination *internal.Pagination, suffixes ...sq.Sqlizer) (*table.ListTraining, error) {

	var list table.ListTraining
	// sql query
	qb, err := tr.FindAllTrainingBaseQuery(ctx, filter, "`training`.*", suffixes...)
	if err != nil {
		return &list, err
	}
	qb = qb.Where(sq.Eq{"`training`.`created_by`": createdBy})

	if qb, err = tr.AddPagination(ctx, qb, pagination); err != nil {
		return &list, err
	}

	// run query
	if err = tr.DB.Select(ctx, &list.Data, qb); err != nil {
		return &list, err
	}

	if pagination == nil || pagination.PerPage == nil || pagination.Page == nil {
		list.TotalCount = len(list.Data)
		return &list, nil
	}

	var listMeta internal.ListMetadata
	if qb, err = tr.FindAllTrainingBaseQuery(ctx, filter, "COUNT(1) AS count"); err != nil {
		return &list, err
	}
	if filter != nil && len(filter.GroupBys) > 0 {
		qb = sq.Select("COUNT(1) AS count").FromSelect(qb, "a")
	}
	qb = qb.Where(sq.Eq{"`training`.`created_by`": createdBy})
	if err = tr.DB.Get(ctx, &listMeta, qb); err != nil {
		return &list, err
	}

	list.TotalCount = listMeta.Count

	return &list, nil

}
func (tr *TrainingRepository) TrainingByID(ctx context.Context, id int, filter *table.TrainingFilter) (table.Training, error) {
	return tr.TrainingByIDWithSuffix(ctx, id, filter)
}

func (tr *TrainingRepository) TrainingByIDWithSuffix(ctx context.Context, id int, filter *table.TrainingFilter, suffixes ...sq.Sqlizer) (table.Training, error) {
	var err error

	// sql query
	qb, err := tr.FindAllTrainingBaseQuery(ctx, filter, "`training`.*", suffixes...)
	if err != nil {
		return table.Training{}, err
	}
	qb = qb.Where(sq.Eq{"`training`.`id`": id})

	// run query
	t := table.Training{}
	err = tr.DB.Get(ctx, &t, qb)
	if err != nil {
		return table.Training{}, err
	}
	return t, nil
}

func (tr *TrainingRepository) TrainingByRequestedBy(ctx context.Context, requestedBy sql.NullInt64, filter *table.TrainingFilter, pagination *internal.Pagination) (*table.ListTraining, error) {
	return tr.TrainingByRequestedByWithSuffix(ctx, requestedBy, filter, pagination)
}

func (tr *TrainingRepository) TrainingByRequestedByWithSuffix(ctx context.Context, requestedBy sql.NullInt64, filter *table.TrainingFilter, pagination *internal.Pagination, suffixes ...sq.Sqlizer) (*table.ListTraining, error) {

	var list table.ListTraining
	// sql query
	qb, err := tr.FindAllTrainingBaseQuery(ctx, filter, "`training`.*", suffixes...)
	if err != nil {
		return &list, err
	}
	qb = qb.Where(sq.Eq{"`training`.`requested_by`": requestedBy})

	if qb, err = tr.AddPagination(ctx, qb, pagination); err != nil {
		return &list, err
	}

	// run query
	if err = tr.DB.Select(ctx, &list.Data, qb); err != nil {
		return &list, err
	}

	if pagination == nil || pagination.PerPage == nil || pagination.Page == nil {
		list.TotalCount = len(list.Data)
		return &list, nil
	}

	var listMeta internal.ListMetadata
	if qb, err = tr.FindAllTrainingBaseQuery(ctx, filter, "COUNT(1) AS count"); err != nil {
		return &list, err
	}
	if filter != nil && len(filter.GroupBys) > 0 {
		qb = sq.Select("COUNT(1) AS count").FromSelect(qb, "a")
	}
	qb = qb.Where(sq.Eq{"`training`.`requested_by`": requestedBy})
	if err = tr.DB.Get(ctx, &listMeta, qb); err != nil {
		return &list, err
	}

	list.TotalCount = listMeta.Count

	return &list, nil

}
